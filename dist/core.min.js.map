{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:/webpack/bootstrap 1935adff8ebf44a19427","webpack:///src/errorReporting/makeJSONError.js","webpack:///src/cyclic.js","webpack:///src/Validation.js","webpack:///src/errorReporting/makeTypeError.js","webpack:///src/makeError.js","webpack:///src/compareTypes.js","webpack:///src/getErrorMessage.js","webpack:///src/types/TypeParameter.js","webpack:///src/invariant.js","webpack:///src/typeConstraints.js","webpack:///src/declarations/ModuleDeclaration.js","webpack:///src/declarations/ParameterizedClassDeclaration.js","webpack:///src/types/ObjectType.js","webpack:///src/types/IntersectionType.js","webpack:///src/types/ParameterizedTypeAlias.js","webpack:///src/types/ParameterizedFunctionType.js","webpack:///src/types/TypeTDZ.js","webpack:///src/makeReactPropTypes.js","webpack:///src/errorReporting/makeWarningMessage.js","webpack:///src/makeUnion.js","webpack:///src/classDecorators.js","webpack:///src/annotateValue.js","webpack:///src/flowTypes/ClassType.js","webpack:///src/index.cjs.js","webpack:///src/primitiveTypes.js","webpack:///node_modules/rollup-regenerator-runtime/regenerator/index.js","webpack:///src/errorReporting/RuntimeTypeError.js","webpack:///src/types/Type.js","webpack:///src/types/AnyType.js","webpack:///src/errorMessages.js","webpack:///src/types/TupleType.js","webpack:///src/types/ArrayType.js","webpack:///src/types/BooleanLiteralType.js","webpack:///src/types/BooleanType.js","webpack:///src/types/EmptyType.js","webpack:///src/types/ExistentialType.js","webpack:///src/types/FlowIntoType.js","webpack:///src/types/FunctionTypeRestParam.js","webpack:///src/types/FunctionTypeParam.js","webpack:///src/types/FunctionTypeReturn.js","webpack:///src/symbols.js","webpack:///src/types/FunctionType.js","webpack:///src/types/GeneratorType.js","webpack:///src/types/TypeParameterApplication.js","webpack:///src/types/TypeConstructor.js","webpack:///src/types/GenericType.js","webpack:///src/types/NullLiteralType.js","webpack:///src/types/VoidType.js","webpack:///src/types/NullableType.js","webpack:///src/types/ObjectTypeProperty.js","webpack:///src/types/ObjectTypeIndexer.js","webpack:///src/types/ObjectTypeCallProperty.js","webpack:///src/declarations/Declaration.js","webpack:///src/declarations/VarDeclaration.js","webpack:///src/declarations/TypeDeclaration.js","webpack:///src/declarations/ModuleExportsDeclaration.js","webpack:///src/declarations/ClassDeclaration.js","webpack:///src/types/PartialType.js","webpack:///src/declarations/ExtendsDeclaration.js","webpack:///src/types/MixedType.js","webpack:///src/types/TypeAlias.js","webpack:///src/types/NumericLiteralType.js","webpack:///src/types/NumberType.js","webpack:///src/types/RefinementType.js","webpack:///src/types/StringLiteralType.js","webpack:///src/types/StringType.js","webpack:///src/types/SymbolLiteralType.js","webpack:///src/types/SymbolType.js","webpack:///src/types/ThisType.js","webpack:///src/types/TypeBox.js","webpack:///src/types/TypeReference.js","webpack:///src/types/UnionType.js","webpack:///src/TypeInferrer.js","webpack:///src/flowTypes/$DiffType.js","webpack:///src/flowTypes/$FlowFixMeType.js","webpack:///src/flowTypes/$KeysType.js","webpack:///src/flowTypes/$ObjMapiType.js","webpack:///src/flowTypes/$ObjMapType.js","webpack:///src/flowTypes/$PropertyType.js","webpack:///src/flowTypes/$ShapeType.js","webpack:///src/flowTypes/$SubType.js","webpack:///src/flowTypes/$SuperType.js","webpack:///src/flowTypes/$TupleMapType.js","webpack:///src/TypeContext.js","webpack:///src/globalContext.js","webpack:///src/registerPrimitiveTypes.js","webpack:///src/registerBuiltins.js","webpack:///src/registerTypePredicates.js","webpack:///array/reduce.js","webpack:///(webpack)/buildin/global.js","webpack:///array/filter.js","webpack:///function/processors.js","webpack:///array/map.js","webpack:///array/shift.js","webpack:///array/concat.js","webpack:///array/find.js","webpack:///array/flatten.js","webpack:///array/mapKey.js","webpack:///array/reverse.js","webpack:///boolean/invert.js","webpack:///object/extend.js","webpack:///object/withProperty.js","webpack:///utils/chain.js","webpack:///core.js","webpack:///node_modules/regenerator-runtime/runtime-module.js","webpack:///node_modules/regenerator-runtime/runtime.js","webpack:///math/sum.js"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","moduleId","installedModules","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","makeJSONError","validation","hasErrors","input","context","errors","_step","Symbol","iterator","_iteratorNormalCompletion","_iterator","next","done","path","_ref2","message","expectedType","expected","toString","actual","typeOf","resolvePath","field","stringifyPath","concat","pointer","join","push","inValidationCycle","type","tracked","cyclicValidation","weakSetHas","e","startValidationCycle","WeakSet","set","endValidationCycle","inToStringCycle","cyclicToString","has","startToStringCycle","add","endToStringCycle","delete","weakset","value","weakSetAdd","weakSetDelete","length","parts","Array","part","validIdentifierOrAccessor","test","String","subject","Map","matchPath","candidate","makeTypeError","prefix","collected","RuntimeTypeError","trim","delimiter","makeError","validate","compareTypes","a","b","result","TypeAlias","TypeParameter","TypeTDZ","unwrap","compareWith","FlowIntoType","AnyType","ExistentialType","MixedType","getErrorMessage","key","params","_len","_key","arguments","errorMessages","replace","flowIntoTypeParameter","typeParameter","existing","FlowIntoSymbol","target","invariant","error","Error","captureStackTrace","addConstraints","constraints","apply","_subject$constraints","toConsumableArray","collectConstraintErrors","_len2","_key2","constraint","violation","constraintsAccept","_len3","_key3","indent","lines","split","getPartial","parent","bodyCreator","partial","PartialType","body","isArray","class","shapeID","typeParameters","typeInstances","_len6","_key6","limit","Math","min","typeInstance","bound","intersect","acceptsCallProperties","callProperties","accepts","compareTypeCallProperties","inputCallProperties","identicalCount","callProperty","j","loop","acceptsWithIndexers","properties","indexers","seen","indexOf","indexer","acceptsKey","acceptsValue","compareTypeWithIndexers","inputIndexers","inputProperties","isGreater","inputProperty","acceptsWithoutIndexers","acceptsExact","compareTypeWithoutIndexers","collectErrorsWithIndexers","_context2","t2","collectErrorsWithoutIndexers","collectErrorsExact","_context4","t1","getPropertyIndex","mergeProperties","source","typeProp","index","typeCreator","_len7","_key7","function","_len5","_key5","getRevealed","container","RevealedValue","reveal","warnedInstances","RevealedName","emitWarningMessage","mixed","Type","ref","makeReactPropTypes","objectType","output","props","propName","componentName","makeWarningMessage","makeUnion","types","merged","UnionType","union","mergeUnionTypes","aTypes","bTypes","bType","makePropertyDescriptor","typeSource","propertyName","descriptor","shouldAssert","augmentExistingAccessors","propertyToAccessor","makePropertyName","getClassName","constructor","resolveType","receiver","safeName","className","initializer","config","writable","objectWithoutProperties","propertyPath","check","undefined","assert","warn","originalSetter","annotateValue","TypeSymbol","checkGenericType","impl","isPrototypeOf","annotation","getAnnotation","checkType","v","thing","primitiveTypes","_regeneratorRuntime","WeakMap","Validation","cyclic","didClear","_step2","_iteratorNormalCompletion2","_iterator2","_temp","possibleConstructorReturn","_this","_ret","TypeError","typeName","TupleType","checkPredicate","inputTypes","ArrayType","inCycle","startCycle","elementType","endCycle","BooleanLiteralType","BooleanType","EmptyType","default","recorded","boundOrDefault","withBinding","id","defaultType","hasError","toJSON","FunctionTypeRestParam","FunctionTypeParam","optional","FunctionTypeReturn","ParentSymbol","NameRegistrySymbol","ModuleRegistrySymbol","CurrentModuleSymbol","TypeConstructorRegistrySymbol","InferrerSymbol","TypeParametersSymbol","TypePredicateRegistrySymbol","FunctionType","returnType","param","acceptsType","annotationParam","any","returnTypeResult","inputParams","inputParam","rest","paramsLength","args","argsLength","_len4","_key4","empty","GeneratorType","return","throw","isValid","yieldType","nextType","TypeParameterApplication","_parent","inner","hasProperty","getProperty","_ref3","_parent2","items","TypeConstructor","GenericType","NullLiteralType","VoidType","NullableType","ObjectTypeProperty","static","isStatic","_typeof","targetPath","isNullable","existsOn","ObjectTypeIndexer","keyResult","valueResult","ObjectTypeCallProperty","Declaration","VarDeclaration","TypeDeclaration","typeAlias","addConstraint","_typeAlias","_typeAlias2","_typeAlias3","_typeAlias4","_typeAlias5","ModuleDeclaration","moduleExports","exporting","prop","declaration","declarations","moduleName","slice","innerContext","import","ModuleExports","ClassDeclaration","superClass","errorPath","errorMessage","isSuperClassOf","current","withDeclaration","superClassName","bodyProps","superProps","seenStatic","expand","ParameterizedClassDeclaration","ExtendsDeclaration","ObjectType","exact","getIndexer","hasIndexer","hasCallProperties","IntersectionType","hasConstraints","NumericLiteralType","NumberType","ParameterizedTypeAlias","identifier","ParameterizedFunctionType","_getPartial$type","getPartial$2","acceptsParams","acceptsReturn","_getPartial$type2","assertParams","assertReturn","RefinementType","StringLiteralType","JSON","stringify","StringType","SymbolLiteralType","SymbolType","ThisType","TypeBox","warnedMissing","TypeReference","normalized","TypeInferer","primitive","inferPrimitive","inferred","inferComplex","null","void","number","boolean","string","symbol","inferFunction","inferObject","fromCharCode","existential","fn","box","inferArray","handler","getTypeConstructor","inferTypeParameters","inferInternal","inferDict","numericIndexers","stringIndexers","isNaN","values","item","inferredType","array","$DiffType","aType","$FlowFixMeType","$KeysType","keys","literal","$ObjMapiType","mapper","applied","invoke","_step3","_iteratorNormalCompletion3","_iterator3","$ObjMapType","$PropertyType","unwrapped","$ShapeType","$SubType","$SuperType","$TupleMapType","tuple","ClassType","instanceType","warnedInvalidReferences","TypeContext","mode","TypeInferrer","Class","inferrer","infer","propertyNames","fromParent","global","getPredicate","predicate","Boolean","_this2","annotate","nameRegistry","var","moduleRegistry","_ref","handlerRegistry","instancePrototype","getPrototypeOf","parentPrototype","parentClass","typeParametersPointer","createContext","currentModule","ModuleExportsDeclaration","head","tail","unshift","_body$properties","_len8","_key8","_len9","_key9","_len10","_key10","method","_len11","_key11","_len12","_key12","_len13","_key13","tdz","_len14","_key14","_target5","_validation$path","from","_len15","_key15","clauses","pop","pattern","_len16","_key16","tests","clause","t","wrappedIterator","_len17","_key17","_$PropertyType","globalContext","__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__","freeze","declareTypeConstructor","Date","mark","getTime","Promise","futureType","keyType","valueType","_ref4","keyTypes","valueTypes","_ref6","findKey","Set","_step4","_step5","_iteratorNormalCompletion5","_iterator5","_step6","_iterator6","_iteratorNormalCompletion6","setPredicate","then","globalContext$2","defineProperties","reduce","reducer","_start","_reducerType","_flowRuntime2","_startType","_returnType","start","_arrayType","_startType2","_returnType2","_retType","ret","g","Function","eval","window","filter","_filterType","_reduce2","r","_rType","_tType","_iType","processors","preProcessor","postProcessor","_preProcessorType","_postProcessorType","_fnType","map","_mapperType","shift","_shiftType","_concatType","find","finder","_finderType","_processors2","_valueType","_filter2","flatten","_arrayType2","mapKey","_keyType","_map2","reverse","invert","_booleanType","_argsType","extend","_sourceType","_targetType","_extends","withProperty","_keysType","obj","_objType","_chain2","_shift2","_defineProperty","chain","initialValue","_initialValueType2","_returnType4","Chain","CHAINABLE","_flatten3","_reverse3","_invert3","numbers","_numbersType","_sum2","bind","_toConsumableArray","_classCallCheck","_initialValueType","actions","action","_actionType","_didIteratorError","_iteratorError","err","chainable","_returnType3","tap","_loop","VERSION","self","hadRuntime","regeneratorRuntime","getOwnPropertyNames","oldRuntime","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","create","Context","_invoke","makeInvokeMethod","tryCatch","arg","GeneratorFunction","GeneratorFunctionPrototype","defineIteratorMethods","forEach","AsyncIterator","resolve","reject","record","hasOwn","__await","process","domain","previousPromise","callInvokeWithMethodAndArg","state","GenStateSuspendedStart","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","GenStateSuspendedYield","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","iteratorSymbol","Op","$Symbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","inModule","runtime","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","displayName","isGeneratorFunction","genFun","ctor","setPrototypeOf","__proto__","awrap","async","iter","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","sum"],"mappings":"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","file":"core.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"core\"] = factory();\n\telse\n\t\troot[\"core\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 16);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1935adff8ebf44a19427","/* @flow */\n\nimport {stringifyPath, resolvePath} from '../Validation';\nimport type Validation from '../Validation';\n\nexport default function makeJSONError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const errors = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : null;\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n    const field = stringifyPath(validation.path.concat(path));\n\n    const pointer = `/${path.join('/')}`;\n\n    errors.push({\n      pointer,\n      field,\n      message,\n      expected,\n      actual\n    });\n  }\n  return errors;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/makeJSONError.js","/* @flow */\n\nimport type Type from './types/Type';\n\n// Tracks whether we're in validation of cyclic objects.\nconst cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\nconst cyclicToString = new WeakSet();\n\nexport function inValidationCycle (type: Type<any>, input: any): boolean {\n  try {\n    const tracked = cyclicValidation.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n  catch (e) {\n    // some exotic values cannot be checked\n    return true;\n  }\n}\n\nexport function startValidationCycle (type: Type<any>, input: any) {\n  let tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  weakSetAdd(tracked, input);\n}\n\nexport function endValidationCycle (type: Type<any>, input: any) {\n  const tracked = cyclicValidation.get(type);\n  if (tracked) {\n    weakSetDelete(tracked, input);\n  }\n}\n\nexport function inToStringCycle (type: Type<any>): boolean {\n  return cyclicToString.has(type);\n}\n\nexport function startToStringCycle (type: Type<any>) {\n  cyclicToString.add(type);\n}\n\nexport function endToStringCycle (type: Type<any>) {\n  cyclicToString.delete(type);\n}\n\n\nexport function weakSetHas <V: any> (weakset: WeakSet<V>, value: V): boolean {\n  try {\n    return weakset.has(value);\n  }\n  catch (e) {\n    return true;\n  }\n}\n\n\nexport function weakSetAdd <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.add(value);\n  }\n  catch (e) {}\n}\n\n\nexport function weakSetDelete <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.delete(value);\n  }\n  catch (e) {}\n}\n\n\n// WEBPACK FOOTER //\n// ../src/cyclic.js","/* @flow */\nimport makeJSONError from './errorReporting/makeJSONError';\n\nimport {weakSetHas, weakSetAdd, weakSetDelete} from './cyclic';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\nexport type IdentifierPath = Array<string | number>;\nexport type ErrorTuple = [IdentifierPath, string, Type<any>];\n\nexport type ValidationJSON<T> = {\n  input: T;\n  errors: Array<{\n    pointer: string;\n    message: string;\n    expected: Type<any>;\n    actual: Type<any>;\n  }>\n};\n\nconst validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\n\nexport default class Validation<T> {\n\n  context: TypeContext;\n\n  input: T;\n\n  path: string[] = [];\n\n  prefix: string = '';\n\n  errors: ErrorTuple[] = [];\n\n  // Tracks whether we're in validation of cyclic objects.\n  cyclic: WeakMap<Type<any>, WeakSet<any>> = new WeakMap();\n\n  constructor (context: TypeContext, input: T) {\n    this.context = context;\n    this.input = input;\n  }\n\n  inCycle (type: Type<any>, input: any): boolean {\n    const tracked = this.cyclic.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n\n  startCycle (type: Type<any>, input: any) {\n    let tracked = this.cyclic.get(type);\n    if (!tracked) {\n      tracked = new WeakSet();\n      this.cyclic.set(type, tracked);\n    }\n    weakSetAdd(tracked, input);\n  }\n\n  endCycle (type: Type<any>, input: any) {\n    const tracked = this.cyclic.get(type);\n    if (tracked) {\n      weakSetDelete(tracked, input);\n    }\n  }\n\n  hasErrors (path: ? IdentifierPath): boolean {\n    if (path) {\n      for (const [candidate] of this.errors) {\n        if (matchPath(path, candidate)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else {\n      return this.errors.length > 0;\n    }\n  }\n\n  addError (path: IdentifierPath, expectedType: Type<any>, message: string): this {\n    this.errors.push([path, message, expectedType]);\n    return this;\n  }\n\n  clearError (path: ? IdentifierPath): boolean {\n    let didClear = false;\n    if (path) {\n      const errors = [];\n      for (const error of this.errors) {\n        if (matchPath(path, error[0])) {\n          didClear = true;\n        }\n        else {\n          errors.push(error);\n        }\n      }\n      this.errors = errors;\n    }\n    else {\n      didClear = this.errors.length > 0;\n      this.errors = [];\n    }\n    return didClear;\n  }\n\n  resolvePath (path: IdentifierPath): any {\n    return resolvePath(this.input, path);\n  }\n\n  toJSON (): * {\n    return makeJSONError(this);\n  }\n\n}\n\nexport function stringifyPath (path: IdentifierPath): string {\n  if (!path.length) {\n    return 'Value';\n  }\n  const {length} = path;\n  const parts = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    }\n    else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = `[${String(part)}]`;\n    }\n    else if (i > 0) {\n      parts[i] = `.${String(part)}`;\n    }\n    else {\n      parts[i] = String(part);\n    }\n  }\n  return parts.join('');\n}\n\nexport function resolvePath (input: any, path: IdentifierPath): any {\n  let subject = input;\n  const {length} = path;\n  for (let i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    }\n    else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nexport function matchPath (path: IdentifierPath, candidate: IdentifierPath): boolean {\n  const {length} = path;\n  if (length > candidate.length) {\n    return false;\n  }\n  for (let i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/Validation.js","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nimport RuntimeTypeError from './RuntimeTypeError';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeTypeError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {prefix, input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n\n    collected.push(\n      `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`\n    );\n  }\n  if (prefix) {\n    return new RuntimeTypeError(`${prefix.trim()} ${collected.join(delimiter)}`);\n  }\n  else {\n    return new RuntimeTypeError(collected.join(delimiter));\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/makeTypeError.js","/* @flow */\n\nimport type {Type} from './types';\nimport makeTypeError from './errorReporting/makeTypeError';\n\nexport default function makeError (expected: Type<any>, input: any): ? TypeError {\n  const {context} = expected;\n  const validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/makeError.js","/* @flow */\n\nimport type Type from './types/Type';\n\nimport {\n  AnyType,\n  ExistentialType,\n  TypeParameter,\n  FlowIntoType,\n  MixedType,\n  TypeAlias,\n  TypeTDZ\n} from './types';\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\nexport default function compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n\n  let result;\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter || b instanceof TypeTDZ) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  }\n  else {\n    result = a.compareWith(b);\n  }\n\n  if (b instanceof AnyType) {\n    // Note: This check cannot be moved higher in the scope,\n    // as this would prevent types from being propagated upwards.\n    return 1;\n  }\n  else {\n    return result;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/compareTypes.js","/* @flow */\n\nimport errorMessages from './errorMessages';\nimport type {ErrorKey} from './errorMessages';\n\n\nexport default function getErrorMessage (key: ErrorKey, ...params: any[]): string {\n  const message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, (m, i) => String(params[i]));\n  }\n  else {\n    return message;\n  }\n}\n\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/getErrorMessage.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport FlowIntoType from './FlowIntoType';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nconst FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\nexport default class TypeParameter<T> extends Type {\n  typeName: string = 'TypeParameter';\n  id: string;\n  bound: ? Type<T>;\n  default: ? Type<T>;\n\n  recorded: ? Type<T>;\n\n  // @flowIssue 252\n  [FlowIntoSymbol]: ? FlowIntoType = null;\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n\n    if (boundOrDefault instanceof FlowIntoType) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      yield* boundOrDefault.errors(validation, path, input);\n      return;\n    }\n    else if (recorded) {\n      // we've already recorded a value for this type parameter\n      yield* recorded.errors(validation, path, input);\n      return;\n    }\n    else if (boundOrDefault) {\n      if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasErrors = false;\n        for (const error of boundOrDefault.errors(validation, path, input)) {\n          hasErrors = true;\n          yield error;\n        }\n        if (hasErrors) {\n          return;\n        }\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n    if (boundOrDefault instanceof FlowIntoType) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      return boundOrDefault.accepts(input);\n    }\n    else if (recorded) {\n      return recorded.accepts(input);\n    }\n    else if (boundOrDefault) {\n      if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n        return true;\n      }\n      else if (!boundOrDefault.accepts(input)) {\n        return false;\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (input instanceof TypeParameter) {\n      // We don't need to check for `recorded` or `bound` fields\n      // because the input has already been unwrapped, so\n      // if we got a type parameter it must be totally generic and\n      // we treat it like Any.\n      return 1;\n    }\n    else if (recorded) {\n      return compareTypes(recorded, input);\n    }\n    else if (boundOrDefault) {\n      return compareTypes(boundOrDefault, input);\n    }\n    else {\n      // A generic type parameter accepts any input.\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (recorded) {\n      return recorded.unwrap();\n    }\n    else if (boundOrDefault) {\n      return boundOrDefault.unwrap();\n    }\n    else {\n      return this;\n    }\n  }\n\n  toString (withBinding?: boolean): string {\n    const {id, bound, default: defaultType} = this;\n    if (withBinding) {\n      if (defaultType) {\n        return `${id} = ${defaultType.toString()}`;\n      }\n      else if (bound) {\n        return `${id}: ${bound.toString()}`;\n      }\n    }\n    return id;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      bound: this.bound,\n      recorded: this.recorded\n    };\n  }\n}\n\nexport function flowIntoTypeParameter <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n  const existing: ? FlowIntoType<T> = (typeParameter: $FlowIssue<252>)[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  const target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  (typeParameter: $FlowIssue<252>)[FlowIntoSymbol] = target;\n  return target;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeParameter.js","/* @flow */\n\nexport default function invariant (input: any, message: string): void {\n  if (!input) {\n    const error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/invariant.js","/* @flow */\n\nimport type {\n  Type,\n  TypeConstraint\n} from './types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport type ConstrainableType<T> = Type<T> & {constraints: TypeConstraint[]};\n\n/**\n * Add constraints to the given subject type.\n */\nexport function addConstraints (subject: ConstrainableType<any>, ...constraints: TypeConstraint[]) {\n  subject.constraints.push(...constraints);\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\nexport function *collectConstraintErrors (subject: ConstrainableType<any>, validation: Validation<any>, path: IdentifierPath, ...input: any[]): Generator<ErrorTuple, void, void> {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    const violation = constraint(...input);\n    if (typeof violation === 'string') {\n      yield [path, violation, this];\n    }\n  }\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nexport function constraintsAccept (subject: ConstrainableType<any>, ...input: any[]): boolean {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    if (typeof constraint(...input) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/typeConstraints.js","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\nimport type ModuleExportsDeclaration from './ModuleExportsDeclaration';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type DeclarationDict = {\n  [name: string]: Type<any>;\n};\n\nexport type ModuleDeclarationDict = {\n  [name: string]: ModuleDeclaration;\n};\n\nimport {NameRegistrySymbol, ModuleRegistrySymbol} from '../symbols';\n\nexport default class ModuleDeclaration extends Declaration {\n  typeName: string = 'ModuleDeclaration';\n\n\n  name: string;\n  innerContext: TypeContext;\n  moduleExports: ? ModuleExportsDeclaration<any>;\n\n  get moduleType (): 'commonjs' | 'es6' {\n    if (this.moduleExports) {\n      return 'commonjs';\n    }\n    else {\n      return 'es6';\n    }\n  }\n\n  get isCommonJS (): boolean {\n    return this.moduleExports ? true : false;\n  }\n\n  get isES6 (): boolean {\n    return this.moduleExports ? false : true;\n  }\n\n  get declarations (): DeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[NameRegistrySymbol];\n  }\n\n  get modules (): ModuleDeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[ModuleRegistrySymbol];\n  }\n\n  get (name: string): ? Type<any> {\n    const {moduleExports} = this;\n    if (moduleExports) {\n      const exporting = moduleExports.unwrap();\n      if (typeof exporting.getProperty === 'function') {\n        const prop = exporting.getProperty(name);\n        if (prop) {\n          return prop.unwrap();\n        }\n      }\n    }\n    else {\n      const declaration = this.declarations[name];\n      if (declaration) {\n        return declaration.unwrap();\n      }\n    }\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // Can't validate a module directly.\n    // @todo should this throw?\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    if (/^\\.\\//.test(moduleName)) {\n      moduleName = `${this.name}${moduleName.slice(1)}`;\n    }\n    return this.innerContext.import(moduleName);\n  }\n\n  toString (): string {\n\n    const {name, declarations, modules, moduleExports} = this;\n    const body = [];\n    for (const name in declarations) { // eslint-disable-line guard-for-in\n      const declaration = declarations[name];\n      body.push(declaration.toString(true));\n    }\n    if (modules) {\n      for (const name in modules) { // eslint-disable-line guard-for-in\n        const module = modules[name];\n        body.push(module.toString());\n      }\n    }\n    if (moduleExports) {\n      body.push(moduleExports.toString());\n    }\n    return `declare module \"${name}\" {\\n${indent(body.join('\\n\\n'))}}`;\n  }\n}\n\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ModuleDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport PartialType from '../types/PartialType';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport type {Type, TypeParameter} from '../types';\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ClassBodyCreator} from './';\n\n\n\nexport default class ParameterizedClassDeclaration<X, O: Object> extends Declaration {\n  typeName: string = 'ParameterizedClassDeclaration';\n  bodyCreator: ClassBodyCreator<X, O>;\n  name: string;\n\n  shapeID: Symbol = Symbol();\n\n  get superClass (): ? Type<$Supertype<O>> {\n    return getPartial(this).type.superClass;\n  }\n\n  get body (): ? Type<O> {\n    return getPartial(this).type.body;\n  }\n\n  get properties(): Property<*, *>[] {\n    return getPartial(this).type.properties;\n  }\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return getPartial(this).compareWith(input);\n  }\n\n  unwrap (...typeInstances: Type<any>[]): Type<O> {\n    return getPartial(this, ...typeInstances).type;\n  }\n\n  isSuperClassOf (candidate: *) {\n    return getPartial(this).type.isSuperClassOf(candidate);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    if (!withDeclaration) {\n      return this.name;\n    }\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return partial.toString(true);\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    const {superClass, body} = type;\n    const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n    return `declare class ${this.name}<${items.join(', ')}>${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n  }\n\n  toJSON () {\n    return getPartial(this).toJSON();\n  }\n}\n\nfunction getPartial <X, O: Object> (parent: ParameterizedClassDeclaration<X, O>, ...typeInstances: Type<any>[]): PartialType<O> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class(parent.name, ...body);\n  }\n  else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  (partial.type: $FlowFixme).shapeID = parent.shapeID;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ParameterizedClassDeclaration.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport ObjectTypeProperty from './ObjectTypeProperty';\nimport ObjectTypeIndexer from './ObjectTypeIndexer';\nimport ObjectTypeCallProperty from './ObjectTypeCallProperty';\n\nimport {ClassDeclaration, ParameterizedClassDeclaration} from '../declarations';\n\nexport type Property<K: string | number, V>\n = ObjectTypeProperty<K, V>\n | ObjectTypeIndexer<K, V>\n ;\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\n\nexport default class ObjectType<T: {}> extends Type {\n  typeName: string = 'ObjectType';\n  properties: ObjectTypeProperty<$Keys<T>, any>[] = [];\n  indexers: ObjectTypeIndexer<any, any>[] = [];\n  callProperties: ObjectTypeCallProperty<any>[] = [];\n  exact: boolean = false;\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<T>, any> {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return property;\n      }\n    }\n    return this.getIndexer(key);\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return true;\n      }\n    }\n    return this.hasIndexer(key);\n  }\n\n\n  /**\n   * Get an indexer with which matches the given key type.\n   */\n  getIndexer <K: string | number> (key: K): ? ObjectTypeIndexer<K, any> {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return indexer;\n      }\n    }\n  }\n\n  /**\n   * Determine whether an indexer exists which matches the given key type.\n   */\n  hasIndexer (key: string | number): boolean {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input === null) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_CALLABLE'), this];\n      }\n    }\n    else if (typeof input !== 'object') {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n\n\n    if (this.indexers.length > 0) {\n      yield* collectErrorsWithIndexers(this, validation, path, input);\n    }\n    else if (this.exact) {\n      yield* collectErrorsExact(this, validation, path, input);\n    }\n    else {\n      yield* collectErrorsWithoutIndexers(this, validation, path, input);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    if (input === null) {\n      return false;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        return false;\n      }\n    }\n    else if (typeof input !== 'object') {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = acceptsWithIndexers(this, input);\n    }\n    else if (this.exact) {\n      result = acceptsExact(this, input);\n    }\n    else {\n      result = acceptsWithoutIndexers(this, input);\n    }\n    endValidationCycle(this, input);\n    return result;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectType || input instanceof ClassDeclaration || input instanceof ParameterizedClassDeclaration)) {\n      return -1;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    let isGreater = false;\n    if (hasCallProperties) {\n      const result = compareTypeCallProperties(this, (input: $FlowFixme));\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = compareTypeWithIndexers(this, (input: $FlowFixme));\n    }\n    else {\n      result = compareTypeWithoutIndexers(this, (input: $FlowFixme));\n    }\n\n    if (result === -1) {\n      return -1;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return result;\n    }\n  }\n\n  toString (): string {\n    const {callProperties, properties, indexers} = this;\n    if (inToStringCycle(this)) {\n      return '$Cycle<Object>';\n    }\n    startToStringCycle(this);\n    const body = [];\n    for (let i = 0; i < callProperties.length; i++) {\n      body.push(callProperties[i].toString());\n    }\n    for (let i = 0; i < properties.length; i++) {\n      body.push(properties[i].toString());\n    }\n    for (let i = 0; i < indexers.length; i++) {\n      body.push(indexers[i].toString());\n    }\n    endToStringCycle(this);\n    if (this.exact) {\n      return `{|\\n${indent(body.join('\\n'))}\\n|}`;\n    }\n    else {\n      return `{\\n${indent(body.join('\\n'))}\\n}`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      callProperties: this.callProperties,\n      properties: this.properties,\n      indexers: this.indexers,\n      exact: this.exact\n    };\n  }\n}\n\nfunction acceptsCallProperties (type: ObjectType<any>, input: any): boolean {\n  const {callProperties} = type;\n  for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\nfunction compareTypeCallProperties (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {callProperties} = type;\n  const inputCallProperties = input.callProperties;\n  let identicalCount = 0;\n  loop: for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n\n    for (let j = 0; j < inputCallProperties.length; j++) {\n      const inputCallProperty = inputCallProperties[j];\n      const result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      }\n      else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  }\n  else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {indexers, properties} = type;\n  const inputIndexers = input.indexers;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (let i = 0; i < indexers.length; i++) {\n    const indexer = indexers[i];\n    for (let j = 0; j < inputIndexers.length; j++) {\n      const inputIndexer = inputIndexers[j];\n      const result = compareTypes(indexer, inputIndexer);\n      if (result === 1) {\n        isGreater = true;\n        continue loop;\n      }\n      else if (result === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction acceptsWithoutIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nfunction acceptsExact (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  const {length} = properties;\n  loop: for (const key in input) { // eslint-disable-line guard-for-in\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        if (!property.accepts(input)) {\n          return false;\n        }\n        continue loop;\n      }\n    }\n    // if we got this far the property does not exist in the object.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {properties} = type;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property.value, inputProperty.value);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction *collectErrorsWithIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value was not accepted by any indexers.\n    yield [path.concat(key), getErrorMessage('ERR_NO_INDEXER'), type];\n  }\n}\n\n\nfunction *collectErrorsWithoutIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n  }\n}\n\n\nfunction *collectErrorsExact (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  const {length} = properties;\n  loop: for (const key in input) { // eslint-disable-line guard-for-in\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        yield* property.errors(validation, path, input);\n        continue loop;\n      }\n    }\n    // if we got this far the property does not exist in the object.\n    yield [path, getErrorMessage('ERR_UNKNOWN_KEY', key), type];\n  }\n}\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\n\nimport ObjectType from './ObjectType';\nimport type {Property} from './ObjectType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class IntersectionType<T: {}> extends Type {\n  typeName: string = 'IntersectionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path, input);\n    }\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty <K: string | number> (key: K): ? Property<K, any> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = length - 1; i >= 0; i--) {\n      const type = types[i];\n      if (typeof type.getProperty === 'function') {\n        const prop = type.getProperty(key);\n        if (prop) {\n          return prop;\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    let identicalCount = 0;\n    if (input instanceof IntersectionType) {\n      const inputTypes = input.types;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const result = compareTypes(type, input);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 0) {\n          identicalCount++;\n        }\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n  }\n\n  unwrap (): ObjectType<T> {\n    const callProperties = [];\n    const properties = [];\n    const indexers = [];\n    const {types, context} = this;\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].unwrap();\n      invariant(type instanceof ObjectType, 'Can only intersect object types');\n      callProperties.push(...type.callProperties);\n      indexers.push(...type.indexers);\n      mergeProperties(properties, type.properties);\n    }\n    return (context: any).object(\n      ...callProperties,\n      ...properties,\n      ...indexers\n    );\n  }\n\n  toString (): string {\n    return this.types.join(' & ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\nfunction getPropertyIndex <K: string | number, V> (name: K, properties: ObjectTypeProperty<*, V>[]): number {\n  for (let i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties <K: string | number, V> (target: ObjectTypeProperty<K, V>[], source: ObjectTypeProperty<K, V>[]): ObjectTypeProperty<K, V>[] {\n  for (let i = 0; i < source.length; i++) {\n    const typeProp = source[i];\n    const index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    }\n    else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/IntersectionType.js","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeCreator} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport TypeAlias from './TypeAlias';\nimport PartialType from './PartialType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport {constraintsAccept} from '../typeConstraints';\n\n\nexport default class ParameterizedTypeAlias <T: Type> extends TypeAlias {\n  typeName: string = 'ParameterizedTypeAlias';\n\n  typeCreator: TypeCreator<T>;\n\n  get properties () {\n    return getPartial(this).type.properties;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    const partial = getPartial(this, ...typeInstances);\n    if (!partial.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(getPartial(this), input);\n    }\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name, ...typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name, ...typeInstances);\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const partial = getPartial(this);\n    const {typeParameters} = partial;\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n\n    const {name} = this;\n    const identifier = typeParameters.length > 0\n                     ? `${name}<${items.join(', ')}>`\n                     : name\n                     ;\n\n    if (withDeclaration) {\n      return `type ${identifier} = ${partial.toString()};`;\n    }\n    else {\n      return identifier;\n    }\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <T> (parent: ParameterizedTypeAlias<T>, ...typeInstances: Type<any>[]): PartialType<T> {\n\n  const {typeCreator, context, name} = parent;\n  const partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ParameterizedTypeAlias.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport PartialType from './PartialType';\nimport type FunctionTypeParam from './FunctionTypeParam';\nimport type FunctionTypeRestParam from './FunctionTypeRestParam';\nimport type FunctionTypeReturn from './FunctionTypeReturn';\nimport type TypeParameter from './TypeParameter';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type FunctionBodyCreator <P, R> = (partial: PartialType<(...params: P[]) => R>) => Array<FunctionTypeParam<P> | FunctionTypeRestParam<P> | FunctionTypeReturn<R>>;\n\n\nexport default class ParameterizedFunctionType <X, P: any, R: any> extends Type {\n  typeName: string = 'ParameterizedFunctionType';\n  bodyCreator: FunctionBodyCreator<P, R>;\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  get params (): FunctionTypeParam<P>[] {\n    return getPartial(this).type.params;\n  }\n\n  get rest (): ? FunctionTypeRestParam<P> {\n    return getPartial(this).type.rest;\n  }\n\n  get returnType (): Type<R> {\n    return getPartial(this).type.returnType;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getPartial(this), input);\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    return getPartial(this).type.acceptsParams(...args);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return getPartial(this).type.acceptsReturn(input);\n  }\n\n  assertParams <T> (...args: T[]): T[] {\n    return getPartial(this).type.assertParams(...args);\n  }\n\n  assertReturn <T> (input: T): T {\n    return getPartial(this).type.assertReturn(input);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<(...params: P[]) => R | any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (): string {\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return type.toString();\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    return `<${items.join(', ')}> ${type.toString()}`;\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <X, P, R> (parent: ParameterizedFunctionType<X, P, R>, ...typeInstances: Type<any>[]): PartialType<(...params: P[]) => R> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  partial.type = context.function(...body);\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ParameterizedFunctionType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nconst RevealedName = Symbol('RevealedName');\nconst RevealedValue = Symbol('RevealedValue');\n\nexport default class TypeTDZ<T: any> extends Type {\n  typeName: string = 'TypeTDZ';\n\n  reveal: TypeRevealer<T>;\n\n  // @flowIssue 252\n  [RevealedName]: ? string = undefined;\n\n  // @flowIssue 252\n  [RevealedValue]: ? Type<T> = undefined;\n\n  get name (): ? string {\n    let name = (this: any)[RevealedName];\n    if (!name) {\n      name = (getRevealed(this): any).name;\n    }\n    return name;\n  }\n\n  set name (value: string) {\n    (this: any)[RevealedName] = value;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* getRevealed(this).errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return getRevealed(this).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getRevealed(this), input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = getRevealed(this);\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return getRevealed(this).unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    return getRevealed(this).toString();\n  }\n\n  toJSON () {\n    return getRevealed(this).toJSON();\n  }\n}\n\nfunction getRevealed <T: any> (container: TypeTDZ<T>): Type<T> {\n  const existing = (container: $FlowIssue<252>)[RevealedValue];\n  if (existing) {\n    return existing;\n  }\n  else {\n    const {reveal} = container;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(container)) {\n        const name = (container: any)[RevealedName];\n        if (name) {\n          container.context.emitWarningMessage(`Failed to reveal type called \"${name}\" in Temporal Dead Zone.`);\n        }\n        else {\n          container.context.emitWarningMessage('Failed to reveal unknown type in Temporal Dead Zone.');\n        }\n        warnedInstances.add(container);\n      }\n      return container.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeTDZ.js","/* @flow */\n\nimport makeError from './makeError';\n\nimport type ObjectType from './types/ObjectType';\n\nexport type PropType<T: {}> = (props: T, propName: string, componentName: string) => ? Error;\n\nexport type PropTypeDict<T: {}> = $ObjMap<T, <V>(v: V) => PropType<V>>;\n\nexport default function makeReactPropTypes <T: {}> (objectType: ObjectType<T>): PropTypeDict<T> {\n  const output = {};\n  if (!objectType.properties) {\n    return output;\n  }\n  for (const property of objectType.properties) {\n    output[property.key] = (props, propName, componentName) => {\n      return makeError(property, props);\n    };\n  }\n  return output;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/makeReactPropTypes.js","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeWarningMessage <T> (validation: Validation<T>): ? string {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n\n    collected.push(\n      `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`\n    );\n  }\n  return `Warning: ${collected.join(delimiter)}`;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/makeWarningMessage.js","/* @flow */\n\nimport UnionType from './types/UnionType';\nimport compareTypes from './compareTypes';\n\nimport AnyType from './types/AnyType';\nimport MixedType from './types/MixedType';\nimport ExistentialType from './types/ExistentialType';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\n\nexport default function makeUnion <T> (context: TypeContext, types: Type<T>[]): Type<T> {\n  const length = types.length;\n  const merged = [];\n  for (let i = 0; i < length; i++) {\n    const type = types[i];\n    if (type instanceof AnyType || type instanceof MixedType || type instanceof ExistentialType) {\n      return (type: $FlowFixme);\n    }\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    }\n    else {\n      merged.push(type);\n    }\n  }\n  const union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes (aTypes: Type<any>[], bTypes: Type<any>[]): void {\n  loop: for (let i = 0; i < bTypes.length; i++) {\n    const bType = bTypes[i];\n    for (let j = 0; j < aTypes.length; j++) {\n      const aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/makeUnion.js","/* @flow */\n\nimport type Type from './types/Type';\n\ntype ValueDescriptor<T> = {\n  writable: boolean;\n  initializer?: () => T;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\ntype AccessorDescriptor<T> = {\n  get: () => ? T;\n  set: (value: T) => void;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\nexport type Descriptor<T>\n = AccessorDescriptor<T>\n | ValueDescriptor<T>\n ;\n\ntype TypeSource<T>\n = (() => Type<T>)\n | Type<T>\n ;\n\nexport function makePropertyDescriptor <O: {} | Function, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: Descriptor<T>, shouldAssert: boolean): ? Descriptor<T> {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, (descriptor: $FlowIssue<AccessorDescriptor<T>>), shouldAssert);\n  }\n  else {\n    return propertyToAccessor(typeSource, input, propertyName, (descriptor: $FlowIssue<ValueDescriptor<T>>), shouldAssert);\n  }\n}\n\nfunction makePropertyName (name: string): string {\n  return `_flowRuntime$${name}`;\n}\n\nfunction getClassName (input: Function | Object): string {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  }\n  else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  }\n  else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType <T> (receiver: any, typeSource: TypeSource<T>): Type<T> {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  }\n  else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: ValueDescriptor<T>, shouldAssert: boolean): AccessorDescriptor<T> {\n  const safeName = makePropertyName(propertyName);\n  const className = getClassName(input);\n  const {initializer, writable, ...config} = descriptor; // eslint-disable-line no-unused-vars\n\n  const propertyPath = [className, propertyName];\n\n  return {\n    ...config,\n    type: 'accessor',\n    get (): ? T {\n      if (safeName in this) {\n        return (this: any)[safeName];\n      }\n      else if (initializer) {\n        const type = resolveType(this, typeSource);\n        const value = initializer.call(this);\n        const context = type.context;\n        context.check(type, value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n        return value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set (value: T): void {\n      const type = resolveType(this, typeSource);\n      const context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      }\n      else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  };\n}\n\nfunction augmentExistingAccessors <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: AccessorDescriptor<T>, shouldAssert: boolean) {\n\n  const className = getClassName(input);\n  const propertyPath = [className, propertyName];\n\n  const originalSetter = descriptor.set;\n\n  descriptor.set = function set (value: T): void {\n    const type = resolveType(this, typeSource);\n    const context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    }\n    else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/classDecorators.js","/* @flow */\n\nimport Type from './types/Type';\n\nimport {TypeSymbol} from './symbols';\n\nexport type Decorator<T> = (input: T) => T;\n\ndeclare function annotateValue <T> (type: Type<T>): Decorator<T>;\ndeclare function annotateValue <T> (input: T, type: Type<T>): T; // eslint-disable-line no-redeclare\n\nexport default function annotateValue (input, type?) { // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  }\n  else {\n    const type = input;\n    return (input) => {\n      input[TypeSymbol] = type;\n      return input;\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/annotateValue.js","/* @flow */\n\nimport Type from '../types/Type';\nimport GenericType from '../types/GenericType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nfunction checkGenericType (context: TypeContext, expected: GenericType, input: Function) {\n  const {impl} = expected;\n  if (typeof impl !== 'function') {\n    // There is little else we can do here, so accept anything.\n    return true;\n  }\n  else if (impl === input || impl.isPrototypeOf(input)) {\n    return true;\n  }\n\n  const annotation = context.getAnnotation(impl);\n  if (annotation == null) {\n    return false;\n  }\n  else {\n    return checkType(context, annotation, input);\n  }\n}\n\nfunction checkType (context: TypeContext, expected: Type<*>, input: Function) {\n  const annotation = context.getAnnotation(input);\n  if (annotation != null) {\n    const result = compareTypes(expected, annotation);\n    return result !== -1;\n  }\n  return true;\n}\n\n\nexport default class ClassType<T> extends Type {\n  typeName: string = 'ClassType';\n\n  instanceType: Type<*>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n      return;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    const isValid = (\n      expectedType instanceof GenericType\n      ? checkGenericType(context, expectedType, input)\n      : checkType(context, expectedType, input)\n    );\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    if (expectedType instanceof GenericType) {\n      return checkGenericType(context, expectedType, input);\n    }\n    else {\n      return checkType(context, expectedType, input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {instanceType} = this;\n    if (input instanceof ClassType) {\n      return compareTypes(instanceType, input.instanceType);\n    }\n    return -1;\n  }\n\n  toString (): string {\n    return `Class<${this.instanceType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      instanceType: this.instanceType\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/ClassType.js","/* @flow */\n\nimport globalContext from './globalContext';\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  PartialType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType,\n  TypeParameterApplication\n} from './types';\n\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport TypeContext from './TypeContext';\n\nfunction v (thing) {\n  return { value: thing }\n}\n\nif (typeof global !== 'undefined' && global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== globalContext) {\n  Object.defineProperties(globalContext, {\n    TypeContext: v(TypeContext),\n    Type: v(Type),\n    TypeBox: v(TypeBox),\n    TypeParameter: v(TypeParameter),\n    TypeReference: v(TypeReference),\n    TypeTDZ: v(TypeTDZ),\n    ParameterizedTypeAlias: v(ParameterizedTypeAlias),\n    TypeAlias: v(TypeAlias),\n    TypeConstructor: v(TypeConstructor),\n    GenericType: v(GenericType),\n    NullLiteralType: v(NullLiteralType),\n    NumberType: v(NumberType),\n    NumericLiteralType: v(NumericLiteralType),\n    BooleanType: v(BooleanType),\n    BooleanLiteralType: v(BooleanLiteralType),\n    SymbolType: v(SymbolType),\n    SymbolLiteralType: v(SymbolLiteralType),\n    StringType: v(StringType),\n    StringLiteralType: v(StringLiteralType),\n    ArrayType: v(ArrayType),\n    ObjectType: v(ObjectType),\n    ObjectTypeCallProperty: v(ObjectTypeCallProperty),\n    ObjectTypeIndexer: v(ObjectTypeIndexer),\n    ObjectTypeProperty: v(ObjectTypeProperty),\n    FunctionType: v(FunctionType),\n    FunctionTypeParam: v(FunctionTypeParam),\n    FunctionTypeRestParam: v(FunctionTypeRestParam),\n    FunctionTypeReturn: v(FunctionTypeReturn),\n    ParameterizedFunctionType: v(ParameterizedFunctionType),\n    PartialType: v(PartialType),\n    RefinementType: v(RefinementType),\n    TypeParameterApplication: v(TypeParameterApplication),\n    GeneratorType: v(GeneratorType),\n    ExistentialType: v(ExistentialType),\n    FlowIntoType: v(FlowIntoType),\n    AnyType: v(AnyType),\n    MixedType: v(MixedType),\n    EmptyType: v(EmptyType),\n    NullableType: v(NullableType),\n    ThisType: v(ThisType),\n    TupleType: v(TupleType),\n    UnionType: v(UnionType),\n    IntersectionType: v(IntersectionType),\n    VoidType: v(VoidType),\n    Declaration: v(Declaration),\n    VarDeclaration: v(VarDeclaration),\n    TypeDeclaration: v(TypeDeclaration),\n    ModuleDeclaration: v(ModuleDeclaration),\n    ModuleExportsDeclaration: v(ModuleExportsDeclaration),\n    ClassDeclaration: v(ClassDeclaration),\n    ParameterizedClassDeclaration: v(ParameterizedClassDeclaration),\n    ExtendsDeclaration: v(ExtendsDeclaration),\n  })\n}\n\nexport default globalContext;\n\n\n\n// WEBPACK FOOTER //\n// ../src/index.cjs.js","/* @flow */\n\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nimport type {\n  Type,\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\n/**\n * Covers our builtin types and makes room for future ones.\n */\ntype PrimitiveTypes = {\n  null: NullLiteralType;\n  empty: EmptyType;\n  number: NumberType;\n  boolean: BooleanType;\n  string: StringType;\n  symbol: SymbolType;\n  any: AnyType;\n  mixed: MixedType;\n  void: VoidType;\n  existential: ExistentialType;\n\n  [name: string]: Type<any>;\n};\n\nconst primitiveTypes: any = {};\n\n(primitiveTypes: PrimitiveTypes);\n\nexport default primitiveTypes;\n\n\n// WEBPACK FOOTER //\n// ../src/primitiveTypes.js","export default require(\"regenerator-runtime\");\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/rollup-regenerator-runtime/regenerator/index.js","/* @flow */\n\nexport default class RuntimeTypeError extends TypeError {\n  name: string = \"RuntimeTypeError\";\n}\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/RuntimeTypeError.js","/* @flow */\n\nimport makeError from '../makeError';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport Validation from '../Validation';\nimport type {ErrorTuple, IdentifierPath} from '../Validation';\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nexport default class Type <T> {\n  typeName: string = 'Type';\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    const validation = new Validation(this.context, input);\n    for (const error of this.errors(validation, [], input)) { // eslint-disable-line no-unused-vars\n      return false;\n    }\n    return true;\n  }\n\n  acceptsType (input: Type<any>): boolean {\n    if (compareTypes(this, input) === -1) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return -1;\n  }\n\n  assert <V: T> (input: V): V {\n    const error = makeError(this, input);\n    if (error) {\n      if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(error, this.assert);\n      }\n      throw error;\n    }\n    return input;\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString () {\n    return '$Type';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/Type.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class AnyType extends Type<any> {\n  typeName: string = 'AnyType';\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return 'any';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/AnyType.js","/* @flow */\n\nconst errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be a promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_MISSING_PROPERTY: 'does not exist on object',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nexport type ErrorKey = $Keys<typeof errorMessages>;\n\nexport default errorMessages;\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorMessages.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TupleType<T> extends Type {\n  typeName: string = 'TupleType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path.concat(i), input[i]);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n\n    if (!context.checkPredicate('Array', input) || input.length < length) {\n      return false;\n    }\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof TupleType)) {\n      return -1;\n    }\n    const types = this.types;\n    const inputTypes = input.types;\n    if (inputTypes.length < types.length) {\n      return -1;\n    }\n    let isGreater = false;\n    for (let i = 0; i < types.length; i++) {\n      const result = compareTypes(types[i], inputTypes[i]);\n      if (result === 1) {\n        isGreater = true;\n      }\n      else if (result === -1) {\n        return -1;\n      }\n    }\n    if (types.length < inputTypes.length) {\n      return 0;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n\n  toString (): string {\n    return `[${this.types.join(', ')}]`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/TupleType.js","/* @flow */\n\nimport Type from './Type';\nimport TupleType from './TupleType';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\nexport default class ArrayType <T> extends Type {\n  typeName: string = 'ArrayType';\n  elementType: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n\n    for (let i = 0; i < length; i++) {\n      yield* elementType.errors(validation, path.concat(i), input[i]);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n    for (let i = 0; i < length; i++) {\n      if (!elementType.accepts(input[i])) {\n        endValidationCycle(this, input);\n        return false;\n      }\n    }\n    endValidationCycle(this, input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {elementType} = this;\n    if (input instanceof TupleType) {\n      const {types} = input;\n      for (let i = 0; i < types.length; i++) {\n        const result = compareTypes(elementType, types[i]);\n        if (result === -1) {\n          return -1;\n        }\n      }\n      return 1;\n    }\n    else if (input instanceof ArrayType) {\n      return compareTypes(elementType, input.elementType);\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {elementType} = this;\n    if (inToStringCycle(this)) {\n      if (typeof elementType.name === 'string') {\n        return `Array<$Cycle<${elementType.name}>>`;\n      }\n      else {\n        return `Array<$Cycle<Object>>`;\n      }\n    }\n    startToStringCycle(this);\n    const output = `Array<${elementType.toString()}>`;\n    endToStringCycle(this);\n    return output;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      elementType: this.elementType\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ArrayType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanLiteralType <T: boolean> extends Type {\n  typeName: string = 'BooleanLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== this.value) {\n      yield [path, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return this.value ? 'true' : 'false';\n  }\n\n  toJSON () {\n    return {\n      type: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/BooleanLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport BooleanLiteralType from './BooleanLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanType extends Type {\n  typeName: string = 'BooleanType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'boolean') {\n      yield [path, getErrorMessage('ERR_EXPECT_BOOLEAN'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'boolean';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType) {\n      return 1;\n    }\n    else if (input instanceof BooleanType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'boolean';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/BooleanType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class EmptyType extends Type {\n  typeName: string = 'EmptyType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield [path, getErrorMessage('ERR_EXPECT_EMPTY'), this];\n  }\n\n  accepts (input: any): boolean {\n    return false; // empty types accepts nothing.\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof EmptyType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'empty';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/EmptyType.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ExistentialType extends Type {\n  typeName: string = 'ExistentialType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return '*';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/ExistentialType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\nexport default class FlowIntoType<T: any> extends Type {\n  typeName: string = 'FlowIntoType';\n\n  typeParameter: TypeParameter<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      yield* bound.errors(validation, path, input);\n      return;\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound) {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.accepts(input);\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound && !bound.accepts(input)) {\n        return false;\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return true;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return true;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return true;\n      }\n      else if (!bound.accepts(input)) {\n        return false;\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.compareWith(input);\n    }\n    if (recorded) {\n      if (bound && compareTypes(bound, input) === -1) {\n        return -1;\n      }\n      const result = compareTypes(recorded, input);\n      if (result === 0) {\n        // our existing type already permits this value, there's nothing to do.\n        return 0;\n      }\n      // we need to make a union\n      typeParameter.recorded = context.union(recorded, input);\n      return 1;\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return 1;\n      }\n      const result = compareTypes(bound, input);\n      if (result === -1) {\n        return -1;\n      }\n    }\n\n    typeParameter.recorded = input;\n    return 0;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.typeParameter.unwrap();\n  }\n\n  toString (withBinding?: boolean): string {\n    return this.typeParameter.toString(withBinding);\n  }\n\n  toJSON () {\n    return this.typeParameter.toJSON();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FlowIntoType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class FunctionTypeRestParam<T> extends Type {\n  typeName: string = 'FunctionTypeRestParam';\n  name: string;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `...${this.name}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionTypeRestParam.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\n\nexport default class FunctionTypeParam<T> extends Type {\n  typeName: string = 'FunctionTypeParam';\n  name: string;\n  optional: boolean;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return;\n    }\n    else {\n      yield* type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return true;\n    }\n    else {\n      return type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (): string {\n    const {optional, type} = this;\n    return `${this.name}${optional ? '?' : ''}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      optional: this.optional,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionTypeParam.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class FunctionTypeReturn<T> extends Type {\n  typeName: string = 'FunctionTypeReturn';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path.concat('[[Return Type]]'), input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeReturn) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  unwrap (): Type<T> {\n    return this.type;\n  }\n\n  toString (): string {\n    const {type} = this;\n    return type.toString();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionTypeReturn.js","/* @flow */\n\nexport const ParentSymbol = Symbol('Parent');\nexport const NameRegistrySymbol = Symbol('NameRegistry');\nexport const ModuleRegistrySymbol = Symbol('ModuleRegistry');\nexport const CurrentModuleSymbol = Symbol('CurrentModule');\nexport const TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nexport const InferrerSymbol = Symbol('Inferrer');\nexport const TraverseValueSymbol = Symbol('TraverseValue');\nexport const TraverseTypeSymbol = Symbol('TraverseType');\nexport const TypeSymbol = Symbol('Type');\nexport const TypeParametersSymbol = Symbol('TypeParameters');\nexport const TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n\n\n\n// WEBPACK FOOTER //\n// ../src/symbols.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\nimport FunctionTypeReturn from './FunctionTypeReturn';\nimport EmptyType from './EmptyType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {TypeSymbol} from '../symbols';\n\nexport default class FunctionType<P, R> extends Type {\n  typeName: string = 'FunctionType';\n  params: FunctionTypeParam<P>[] = [];\n  rest: ? FunctionTypeRestParam<P>;\n  returnType: FunctionTypeReturn<R>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n      return;\n    }\n    const annotation = input[TypeSymbol];\n    const {returnType, params} = this;\n    if (annotation) {\n      if (!annotation.params) {\n        return;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        yield [\n          path,\n          getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()),\n          this\n        ];\n      }\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const {returnType, params} = this;\n    const annotation = input[TypeSymbol];\n    if (annotation) {\n      if (!annotation.params) {\n        return true;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          return false;\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          return false;\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        return false;\n      }\n      return true;\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof FunctionType)) {\n      return -1;\n    }\n    const returnType = this.returnType;\n    const inputReturnType = input.returnType;\n    let isGreater = false;\n    const returnTypeResult = compareTypes(returnType, inputReturnType);\n    if (returnTypeResult === -1) {\n      return -1;\n    }\n    else if (returnTypeResult === 1) {\n      isGreater = true;\n    }\n\n    const params = this.params;\n    const inputParams = input.params;\n    for (let i = 0; i < params.length; i++) {\n      const param = params[i];\n      const inputParam = i >= inputParams.length ? input.rest : inputParams[i];\n      if (inputParam == null) {\n        return -1;\n      }\n      const result = compareTypes(param, inputParam);\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.accepts(args[i])) {\n          return false;\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return false;\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.accepts(args[i])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  assertParams (...args: any[]): P[] {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        param.assert(args[i]);\n      }\n      else {\n        param.assert(undefined);\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        rest.assert(args[i]);\n      }\n    }\n\n    return args;\n  }\n\n  assertReturn <T> (input: any): T {\n    this.returnType.assert(input);\n    return input;\n  }\n\n  invoke (...args: Type<P>[]): Type<R> | EmptyType {\n    const {params, rest, context} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return context.empty();\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n    }\n\n    return this.returnType.type;\n  }\n\n  toString (): string {\n    const {params, rest, returnType} = this;\n    const args = [];\n    for (let i = 0; i < params.length; i++) {\n      args.push(params[i].toString());\n    }\n    if (rest) {\n      args.push(rest.toString());\n    }\n    return `(${args.join(', ')}) => ${returnType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      params: this.params,\n      rest: this.rest,\n      returnType: this.returnType\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class GeneratorType<Y, R, N> extends Type {\n  typeName: string = 'GeneratorType';\n  yieldType: Type<Y>;\n  returnType: Type<R>;\n  nextType: Type<N>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const isValid = input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_GENERATOR'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof GeneratorType)) {\n      const result = compareTypes(this.yieldType, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n    let isGreater = false;\n    let result = compareTypes(this.yieldType, input.yieldType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.returnType, input.returnType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.nextType, input.nextType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsYield (input: any): boolean {\n    return this.yieldType.accepts(input);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  acceptsNext (input: any): boolean {\n    return this.nextType.accepts(input);\n  }\n\n  assertYield (input: Y): Y {\n    return this.yieldType.assert(input);\n  }\n\n  assertReturn (input: R): R {\n    return this.returnType.assert(input);\n  }\n\n  assertNext (input: N): N {\n    return this.nextType.assert(input);\n  }\n\n  toString (): string {\n    const {yieldType, returnType, nextType} = this;\n    return `Generator<${yieldType.toString()}, ${returnType.toString()}, ${nextType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      yieldType: this.yieldType,\n      returnType: this.returnType,\n      nextType: this.nextType\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/GeneratorType.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ApplicableType} from './';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\n/**\n * # TypeParameterApplication\n *\n */\nexport default class TypeParameterApplication<X, T> extends Type {\n  typeName: string = 'TypeParameterApplication';\n  parent: ApplicableType<T>;\n  typeInstances: Type<X>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {parent, typeInstances} = this;\n    yield* parent.errors(validation, path, input, ...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    const {parent, typeInstances} = this;\n    return parent.accepts(input, ...typeInstances);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return this.parent.compareWith(input, ...this.typeInstances);\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).hasProperty === 'function') {\n      return (inner: $FlowIgnore).hasProperty(name, ...this.typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).getProperty === 'function') {\n      return (inner: $FlowIgnore).getProperty(name, ...this.typeInstances);\n    }\n  }\n\n  unwrap () {\n    return this.parent.unwrap(...this.typeInstances);\n  }\n\n  toString (): string {\n    const {parent, typeInstances} = this;\n    const {name} = parent;\n    if (typeInstances.length) {\n      const items = [];\n      for (let i = 0; i < typeInstances.length; i++) {\n        const typeInstance = typeInstances[i];\n        items.push(typeInstance.toString());\n      }\n      return `${name}<${items.join(', ')}>`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeInstances: this.typeInstances\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeParameterApplication.js","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type {Constructor} from './';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeConstructor<T> extends Type {\n  typeName: string = 'TypeConstructor';\n  name: string;\n  impl: ? Constructor<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts <P> (input: any, ...typeInstances: Type<P>[]): boolean {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement accepts().`);\n      warnedInstances.add(this);\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement compareWith().`);\n      warnedInstances.add(this);\n    }\n    return -1;\n  }\n\n  inferTypeParameters <P> (input: any): Type<P>[] {\n    return [];\n  }\n\n  apply <P> (...typeInstances: Type<P>[]): TypeParameterApplication<P, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): TypeConstructor<T> {\n    return this;\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeConstructor.js","/* @flow */\n\nimport TypeConstructor from './TypeConstructor';\n\nimport type Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class GenericType extends TypeConstructor {\n\n  typeName: string = 'GenericType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {name, impl, context} = this;\n    if (!(input instanceof impl)) {\n      const annotation = context.getAnnotation(impl);\n      if (annotation) {\n        yield* annotation.errors(validation, path, input);\n      }\n      else {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', name), this];\n      }\n    }\n  }\n\n  accepts <P> (input: any, ...typeInstances: Type<P>[]): boolean {\n    const {context, impl} = this;\n    if (input instanceof impl) {\n      return true;\n    }\n    const annotation = context.getAnnotation(impl);\n    if (annotation) {\n      return annotation.accepts(input);\n    }\n    else {\n      return false;\n    }\n  }\n\n  compareWith <P> (input: Type<any>, ...typeInstances: Type<P>[]): -1 | 0 | 1 {\n    const {context, impl} = this;\n    const annotation = context.getAnnotation(impl);\n    if (annotation) {\n      const expected = annotation.unwrap(...typeInstances);\n      return compareTypes(input, expected);\n    }\n    else if (input instanceof GenericType && (input.impl === impl || (impl && impl.isPrototypeOf(input.impl)))) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  unwrap <P> (...typeInstances: Type<P>[]) {\n    const {context, impl} = this;\n    if (typeof impl !== 'function') {\n      return this;\n    }\n    const annotation = context.getAnnotation(impl);\n    if (annotation != null) {\n      return (annotation.unwrap(...typeInstances): any);\n    }\n    else {\n      return this;\n    }\n  }\n\n  inferTypeParameters <P> (input: any): Type<P>[] {\n    return [];\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/GenericType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullLiteralType extends Type {\n  typeName: string = 'NullLiteralType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== null) {\n      yield [path, getErrorMessage('ERR_EXPECT_NULL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === null;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'null';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/NullLiteralType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class VoidType extends Type {\n  typeName: string = 'VoidType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== undefined) {\n      yield [path, getErrorMessage('ERR_EXPECT_VOID'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === undefined;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof VoidType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'void';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/VoidType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport NullLiteralType from './NullLiteralType';\nimport VoidType from './VoidType';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullableType<T> extends Type<T> {\n  typeName: string = 'NullableType';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input != null) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (input == null) {\n      return true;\n    }\n    else {\n      return this.type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType || input instanceof VoidType) {\n      return 1;\n    }\n    else if (input instanceof NullableType) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `? ${this.type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/NullableType.js","/* @flow */\n\nimport Type from './Type';\nimport NullableType from './NullableType';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ObjectTypeProperty<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeProperty';\n  key: K;\n  value: Type<V>;\n  optional: boolean;\n  // @flowIgnore\n  'static': boolean = false;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): ObjectTypeProperty<K, V> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n  \n  /**\n   * Determine whether the property is nullable.\n   */\n  isNullable(): boolean {\n    return this.value instanceof NullableType;\n  }\n  \n  /**\n   * Determine whether the property exists on the given input or its prototype chain.\n   */\n  existsOn(input: Object): boolean {\n    // @flowIgnore\n    const {key, static: isStatic} = this;\n    return key in (isStatic ? input.constructor : input) === true;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        if (!optional) {\n          yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        }\n        return;\n      }\n      targetPath.push(key);\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n      targetPath = path.concat(key);\n    }\n    if (optional && target === undefined) {\n      return;\n    }\n    if (this.isNullable() && !this.existsOn(input)) {\n      yield [targetPath, getErrorMessage('ERR_MISSING_PROPERTY'), this];\n      return;\n    }\n    let hasErrors = false;\n    for (const error of value.errors(validation, targetPath, target)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, targetPath, target);\n    }\n  }\n\n  accepts (input: Object): boolean {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return optional ? true : false;\n      }\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n    }\n    \n    if (optional && target === undefined) {\n      return true;\n    }\n    \n    if (this.isNullable() && !this.existsOn(input)) {\n      return false;\n    }\n    \n    if (!value.accepts(target)) {\n      return false;\n    }\n    else {\n      return constraintsAccept(this, target);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeProperty)) {\n      return -1;\n    }\n    else if (input.key !== this.key) {\n      return -1;\n    }\n    else {\n      return compareTypes(this.value, input.value);\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    let key = this.key;\n    // @flowIssue 252\n    if (typeof key === 'symbol') {\n      key = `[${key.toString()}]`;\n    }\n    if (this.static) {\n      return `static ${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n    else {\n      return `${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      key: this.key,\n      value: this.value,\n      optional: this.optional\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectTypeProperty.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport ObjectTypeProperty from './ObjectTypeProperty';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeIndexer<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeIndexer';\n  id: string;\n  key: Type<K>;\n  value: Type<V>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, key: any, value: any): Generator<ErrorTuple, void, void> {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n\n    yield* this.key.errors(validation, path.concat('[[Key]]'), key);\n    yield* this.value.errors(validation, path.concat(key), value);\n  }\n\n  accepts (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  acceptsKey (key: any): boolean {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n    return this.key.accepts(key);\n  }\n\n  acceptsValue (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ObjectTypeProperty) {\n      if (!this.key.accepts(input.key)) {\n        return -1;\n      }\n      else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n    else if (!(input instanceof ObjectTypeIndexer)) {\n      return -1;\n    }\n\n    const keyResult = compareTypes(this.key, input.key);\n    if (keyResult === -1) {\n      return -1;\n    }\n    const valueResult = compareTypes(this.value, input.value);\n    if (valueResult === -1) {\n      return -1;\n    }\n\n    if (keyResult === 0 && valueResult === 0) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    return `[${this.id}: ${this.key.toString()}]: ${this.value.toString()};`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      key: this.key,\n      value: this.value\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectTypeIndexer.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeCallProperty<T: Function> extends Type {\n  typeName: string = 'ObjectTypeCallProperty';\n  value: Type<T>;\n  // @flowIgnore\n  'static': boolean = false;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        return;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n      targetPath = path;\n    }\n    yield* value.errors(validation, targetPath, target);\n  }\n\n  accepts (input: any): boolean {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return false;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n    }\n    return value.accepts(target);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeCallProperty)) {\n      return -1;\n    }\n    return compareTypes(this.value, input.value);\n  }\n\n  unwrap (): Type<T> {\n    return this.value.unwrap();\n  }\n\n\n  toString (): string {\n    if (this.static) {\n      return `static ${this.value.toString()};`;\n    }\n    else {\n      return this.value.toString();\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectTypeCallProperty.js","/* @flow */\n\nimport Type from '../types/Type';\n\nexport default class Declaration extends Type {\n  name: string;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/Declaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {Type, TypeConstraint} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class VarDeclaration<T> extends Declaration {\n  typeName: string = 'VarDeclaration';\n\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): VarDeclaration<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare var ${this.name}: ${this.type.toString()};`;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/VarDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {\n  Type,\n  TypeAlias,\n  ParameterizedTypeAlias,\n  TypeConstraint,\n  TypeParameterApplication,\n  ObjectTypeProperty\n} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TypeDeclaration<T> extends Declaration {\n  typeName: string = 'TypeDeclaration';\n\n  get type (): Type<T> {\n    return this.typeAlias.type;\n  }\n\n  typeAlias: TypeAlias<T> | ParameterizedTypeAlias<T>;\n\n  addConstraint (...constraints: TypeConstraint[]): TypeDeclaration<T> {\n    this.typeAlias.addConstraint(...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.typeAlias.errors(validation, path, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    return this.typeAlias.apply(...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    return this.typeAlias.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.typeAlias, input);\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    return this.typeAlias.hasProperty(name, ...typeInstances);\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    return this.typeAlias.getProperty(name, ...typeInstances);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return this.typeAlias.unwrap(...typeInstances);\n  }\n\n  toString (): string {\n    return `declare ${this.typeAlias.toString(true)};`;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/TypeDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ModuleExports<T> extends Declaration {\n  typeName: string = 'ModuleExports';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare module.exports: ${this.type.toString()};`;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ModuleExportsDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport getErrorMessage from \"../getErrorMessage\";\nimport compareTypes from '../compareTypes';\n\nimport type ParameterizedClassDeclaration from './ParameterizedClassDeclaration';\n\nimport type {Type, ObjectType} from '../types';\n\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ClassDeclaration<O: {}> extends Declaration {\n  typeName: string = 'ClassDeclaration';\n\n  name: string;\n  superClass: ? Type<any>;\n  body: ObjectType<O>;\n\n  shapeID: Symbol = Symbol();\n\n  get properties (): Array<*> {\n    const {body, superClass} = this;\n    if (superClass == null) {\n      return body.properties;\n    }\n    const bodyProps = body.properties;\n    const superProps = (superClass.unwrap(): $FlowFixme).properties;\n    const seen = {};\n    const seenStatic = {};\n    const props = [];\n    for (let i = 0; i < superProps.length; i++) {\n      const prop = superProps[i];\n      props.push(prop);\n      if (prop.static) {\n        seenStatic[prop.key] = i;\n      }\n      else {\n        seen[prop.key] = i;\n      }\n    }\n    for (let i = 0; i < bodyProps.length; i++) {\n      const prop = bodyProps[i];\n      if (seen[prop.key]) {\n        props[i] = prop;\n      }\n      else {\n        props.push(prop);\n      }\n    }\n    return props;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name), this];\n      return;\n    }\n    if (superClass) {\n      for (const [errorPath, errorMessage, expectedType] of superClass.errors(validation, path, input)) {\n        const propertyName = errorPath[path.length];\n        if (body.getProperty(propertyName)) {\n          continue;\n        }\n        else {\n          yield [errorPath, errorMessage, expectedType];\n        }\n      }\n    }\n    yield* body.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    else if (superClass && !superClass.accepts(input)) {\n      return false;\n    }\n    else if (!body.accepts(input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ClassDeclaration) {\n      if (input === this) {\n        return 0;\n      }\n      else if (this.isSuperClassOf(input)) {\n        return 1;\n      }\n      else {\n        return -1;\n      }\n    }\n    return compareTypes(this.body, input);\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<O>, any> {\n    const {body, superClass} = this;\n    const prop = body.getProperty(key);\n    if (prop) {\n      return prop;\n    }\n    else if (superClass && typeof superClass.getProperty === 'function') {\n      return superClass.getProperty(key);\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {body, superClass} = this;\n    if (body.hasProperty(key)) {\n      return true;\n    }\n    else if (superClass && typeof superClass.hasProperty === 'function') {\n      return superClass.hasProperty(key);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Determine whether this class declaration represents a super class of\n   * the given type.\n   */\n  isSuperClassOf <X: {}> (candidate: ClassDeclaration<X> | ParameterizedClassDeclaration<*, X>) {\n    const {body, shapeID} = this;\n    let current = candidate;\n\n    while (current != null) {\n      if (current === this || current === body || current.shapeID === shapeID) {\n        return true;\n      }\n      if (current instanceof ClassDeclaration) {\n        current = current.superClass;\n      }\n      else {\n        current = current.unwrap();\n      }\n    }\n    return false;\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {name, superClass, body} = this;\n    if (withDeclaration) {\n      const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n      return `declare class ${name}${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n    }\n    else {\n      return name;\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ClassDeclaration.js","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\nimport TypeParameterApplication from './TypeParameterApplication';\n\nimport {collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class PartialType<X, T> extends Type {\n  typeName: string = 'PartialType';\n  name: string;\n  type: Type<T>;\n  typeParameters: TypeParameter<X>[] = [];\n  constraints: ? TypeConstraint[];\n\n  typeParameter (id: string, bound?: Type<X>, defaultType?: Type<X>): TypeParameter<X> {\n    const target = new TypeParameter(this.context);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    this.typeParameters.push(target);\n    return target;\n  }\n\n  apply (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {constraints, type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors && constraints) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {constraints, type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (constraints && !constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (expand?: boolean): string {\n    const {type} = this;\n    return type.toString(expand);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeParameters: this.typeParameters,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/PartialType.js","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ExtendsDeclaration<T> extends Declaration {\n  typeName: string = 'ExtendsDeclaration';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {type} = this;\n    if (withDeclaration) {\n      return `extends ${type.toString()}`;\n    }\n    else {\n      return type.toString();\n    }\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ExtendsDeclaration.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class MixedType extends Type {\n  typeName: string = 'MixedType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  toString (): string {\n    return 'mixed';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/MixedType.js","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class TypeAlias<T> extends Type {\n  typeName: string = 'TypeAlias';\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): TypeAlias<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  get properties () {\n    return this.type.properties;\n  }\n\n  get hasConstraints (): boolean {\n    return this.constraints.length > 0;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const {name, type} = this;\n    if (withDeclaration) {\n      return `type ${name} = ${type.toString()};`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeAlias.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumericLiteralType<T: number> extends Type {\n  typeName: string = 'NumericLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumericLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return `${this.value}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/NumericLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport NumericLiteralType from './NumericLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumberType extends Type {\n  typeName: string = 'NumberType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'number') {\n      yield [path, getErrorMessage('ERR_EXPECT_NUMBER'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'number';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumberType) {\n      return 0;\n    }\n    else if (input instanceof NumericLiteralType) {\n      return 1;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'number';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/NumberType.js","\nimport Type from './Type';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class RefinementType<T> extends Type {\n  typeName: string = 'RefinementType';\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): RefinementType<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `$Refinment<${type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/RefinementType.js","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringLiteralType<T: string> extends Type {\n  typeName: string = 'StringLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return JSON.stringify(this.value);\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/StringLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport StringLiteralType from './StringLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringType extends Type {\n  typeName: string = 'StringType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'string') {\n      yield [path, getErrorMessage('ERR_EXPECT_STRING'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'string';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType) {\n      return 1;\n    }\n    else if (input instanceof StringType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'string';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/StringType.js","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from '../getErrorMessage';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolLiteralType<T: Symbol> extends Type {\n  typeName: string = 'SymbolLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return `typeof ${String(this.value)}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/SymbolLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport SymbolLiteralType from './SymbolLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolType extends Type {\n  typeName: string = 'SymbolType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIssue 252\n    if (typeof input !== 'symbol') {\n      yield [path, getErrorMessage('ERR_EXPECT_SYMBOL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'symbol';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType) {\n      return 1;\n    }\n    else if (input instanceof SymbolType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'Symbol';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/SymbolType.js","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport getErrorMessage from \"../getErrorMessage\";\n\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\nexport default class ThisType<T> extends Type {\n  typeName: string = 'ThisType';\n\n  recorded: ? T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {recorded} = this;\n    if (input === recorded) {\n      return;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return;\n    }\n    else if (recorded != null) {\n      yield [path, getErrorMessage('ERR_EXPECT_THIS'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {recorded} = this;\n    if (input === recorded) {\n      return true;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return true;\n    }\n    else if (recorded != null) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ThisType)) {\n      return -1;\n    }\n    else if (input.recorded && this.recorded) {\n      return input.recorded === this.recorded ? 0 : -1;\n    }\n    else if (this.recorded) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString (withBinding?: boolean): string {\n    return 'this';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ThisType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeBox<T: any> extends Type {\n  typeName: string = 'TypeBox';\n\n  reveal: TypeRevealer<T>;\n\n  get name (): ? string {\n    return (this.type: any).name;\n  }\n\n  get type (): Type<T> {\n    const {reveal} = this;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(this)) {\n        this.context.emitWarningMessage('Failed to reveal boxed type.');\n        warnedInstances.add(this);\n      }\n      return this.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return this.context.ref(type);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this.type;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return this.type.toString();\n  }\n\n  toJSON () {\n    return this.type.toJSON();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeBox.js","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport compareTypes from '../compareTypes';\n\nconst warnedMissing = {};\n\nexport default class TypeReference<T: any> extends Type {\n  typeName: string = 'TypeReference';\n  name: string;\n\n  get type (): Type<T> {\n    const {context, name} = this;\n    const type = context.get(name);\n    if (!type) {\n      if (!warnedMissing[name]) {\n        context.emitWarningMessage(`Cannot resolve type: ${name}`);\n        warnedMissing[name] = true;\n      }\n      return (context.any(): any);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return (this.type.unwrap(): any);\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeReference.js","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport compareTypes from '../compareTypes';\n\nexport default class UnionType<T> extends Type {\n  typeName: string = 'UnionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return;\n      }\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', this.toString()), this];\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    if (input instanceof UnionType) {\n      const inputTypes = input.types;\n      let identicalCount = 0;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n\n      if (identicalCount === types.length) {\n        return 0;\n      }\n      else {\n        return 1;\n      }\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (compareTypes(type, input) >= 0) {\n          return 1;\n        }\n      }\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {types} = this;\n    const normalized = new Array(types.length);\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i];\n      if (type.typeName === 'FunctionType' || type.typeName === 'ParameterizedFunctionType') {\n        normalized[i] = `(${type.toString()})`;\n      }\n      else {\n        normalized[i] = type.toString();\n      }\n    }\n    return normalized.join(' | ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/UnionType.js","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nimport type {\n  Type,\n  ArrayType,\n  ObjectType\n} from './types';\n\ntype Inferred = Map<Object, Type<any>>;\n\nexport class TypeInferer {\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  infer <T> (input: T): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    const inferred = new Map();\n    return this.inferComplex(input, inferred);\n  }\n\n  inferInternal <T> (input: T, inferred: Inferred): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    return this.inferComplex(input, inferred);\n  }\n\n  inferPrimitive <T> (input: T): ? Type<T> {\n    const {context} = this;\n    if (input === null) {\n      return (context.null(): any);\n    }\n    else if (input === undefined) {\n      return (context.void(): any);\n    }\n    else if (typeof input === 'number') {\n      return (context.number(): any);\n    }\n    else if (typeof input === 'boolean') {\n      return (context.boolean(): any);\n    }\n    else if (typeof input === 'string') {\n      return (context.string(): any);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return context.symbol((input: any));\n    }\n    else {\n      return undefined;\n    }\n  }\n\n  inferComplex <T> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n\n    if (typeof input === 'function') {\n      return (this.inferFunction(input, inferred): any);\n    }\n    else if (input !== null && typeof input === 'object') {\n      return (this.inferObject(input, inferred): any);\n    }\n    else {\n      return (context.any(): any);\n    }\n  }\n\n  inferFunction <T: Function> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n    const {length} = input;\n    const body = new Array(length + 1);\n    for (let i = 0; i < length; i++) {\n      body[i] = context.param(\n        String.fromCharCode(97 + i),\n        context.existential()\n      );\n    }\n    body[length] = context.return(context.existential());\n    return (context.fn(...body): any);\n  }\n\n  inferObject <T: Object> (input: T, inferred: Inferred): Type<T> {\n    const existing = inferred.get(input);\n    if (existing) {\n      return existing;\n    }\n    const {context} = this;\n    let type;\n\n    // Temporarily create a box for this type to catch cyclical references.\n    // Nested references to this object will receive the boxed type.\n    const box = context.box(() => type);\n    inferred.set(input, box);\n\n    if (context.checkPredicate('Array', input)) {\n      type = this.inferArray((input: any), inferred);\n    }\n    else if (!(input instanceof Object)) {\n      type = this.inferDict(input, inferred);\n    }\n    else if (input.constructor !== Object) {\n      const handler = context.getTypeConstructor(input.constructor);\n      if (handler) {\n        const typeParameters = handler.inferTypeParameters(input);\n        type = handler.apply(...typeParameters);\n      }\n      else {\n        type = context.ref(input.constructor);\n      }\n    }\n    else {\n      const body = [];\n      for (const key in input) { // eslint-disable-line\n        const value = input[key];\n        body.push(context.property(key, this.inferInternal(value, inferred)));\n      }\n      type = context.object(...body);\n    }\n\n    // Overwrite the box with the real value.\n    inferred.set(input, type);\n    return (type: any);\n  }\n\n  inferDict <T: Object> (input: T, inferred: Inferred): ObjectType<T> {\n    const numericIndexers = [];\n    const stringIndexers = [];\n    loop: for (const key in input) { // eslint-disable-line\n      const value = input[key];\n      const types = isNaN(+key) ? stringIndexers : numericIndexers;\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (type.accepts(value)) {\n          continue loop;\n        }\n      }\n      types.push(this.inferInternal(value, inferred));\n    }\n\n    const {context} = this;\n    const body = [];\n    if (numericIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          numericIndexers[0]\n        )\n      );\n    }\n    else if (numericIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          context.union(...numericIndexers)\n        )\n      );\n    }\n\n    if (stringIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          stringIndexers[0]\n        )\n      );\n    }\n    else if (stringIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          context.union(...stringIndexers)\n        )\n      );\n    }\n\n    return context.object(...body);\n  }\n\n  inferArray <T> (input: T[], inferred: Inferred): ArrayType<T> {\n    const {context} = this;\n    const types = [];\n    const values = [];\n    const {length} = input;\n    loop: for (let i = 0; i < length; i++) {\n      const item = input[i];\n      const inferredType = this.inferInternal(item, inferred);\n      for (let j = 0; j < types.length; j++) {\n        const type = types[j];\n        if (type.accepts(item) && inferredType.accepts(values[j])) {\n          continue loop;\n        }\n      }\n      types.push(inferredType);\n      values.push(item);\n    }\n    if (types.length === 0) {\n      return (context.array(context.any()): any);\n    }\n    else if (types.length === 1) {\n      return context.array(types[0]);\n    }\n    else {\n      return context.array(context.union(...types));\n    }\n  }\n\n}\n\nexport default TypeInferer;\n\n\n// WEBPACK FOOTER //\n// ../src/TypeInferrer.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nexport default class $DiffType<A: {}, B: {}> extends Type<$Diff<A, B>> {\n  typeName: string = '$DiffType';\n\n  aType: Type<A>;\n  bType: Type<B>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      yield* property.errors(validation, path.concat(property.key), input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      if (!property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Diff<A, B>> {\n    let {aType, bType} = this;\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    const args = [];\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      args.push(property);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Diff<${this.aType.toString()}, ${this.bType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      aType: this.aType,\n      bType: this.bType\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$DiffType.js","/* @flow */\n\nimport Type from '../types/Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $FlowFixMeType extends Type<any> {\n  typeName: string = '$FlowFixMeType';\n\n  *errors (validation: Validation<any>, input: any, path: IdentifierPath = []): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  unwrap (): Type<any> {\n    return this;\n  }\n\n  toString (): string {\n    return '$FlowFixMe';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$FlowFixMeType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The set of keys of T.\n\nexport default class $KeysType<T: {}> extends Type<$Keys<T>> {\n  typeName: string = '$KeysType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return;\n      }\n    }\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      keys[i] = properties[i].key;\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', keys.join(' | ')), this];\n  }\n\n  accepts (input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Keys<T>> {\n    const context = this.context;\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      keys[i] = context.literal(property.key);\n    }\n    return this.context.union(...keys);\n  }\n\n  toString (): string {\n    return `$Keys<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$KeysType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys and values in an object.\n\nexport default class $ObjMapiType<O: {}, M: Mapper> extends Type<$ObjMapi<O, M>> {\n  typeName: string = '$ObjMapiType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMapi<O, M>> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key), prop.value)\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMapi<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ObjMapiType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys in an object.\n\nexport default class $ObjMapType<O: {}, M: Mapper> extends Type<$ObjMap<O, M>> {\n  typeName: string = '$ObjMapType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMap<O, M>> {\n\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key))\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMap<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ObjMapType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The type of the named object property\n\nexport default class $PropertyType<O: {}, P: string | number | Symbol> extends Type {\n  typeName: string = '$PropertyType';\n\n  object: Type<O>;\n\n  property: P;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.unwrap().errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.unwrap().accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<*> {\n    const {object, property} = this;\n    const unwrapped = object.unwrap();\n    invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n    return unwrapped.getProperty(property).unwrap();\n  }\n\n  toString (): string {\n    return `$PropertyType<${this.object.toString()}, ${String(this.property)}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      property: this.property\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$PropertyType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nexport default class $ShapeType<T> extends Type<$Shape<T>> {\n  typeName: string = '$ShapeType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {type} = this;\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property) {\n        continue;\n      }\n      yield* property.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {type} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property || !property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Shape<T>> {\n    let {type} = this;\n    type = type.unwrap();\n    const context = this.context;\n    invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n    const properties = type.properties;\n    const args = new Array(properties.length);\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      args[i] = context.property(property.key, property.value, true);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Shape<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ShapeType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $SubType<T> extends Type<$Subtype<T>> {\n  typeName: string = '$SubType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(input, path);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Subtype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Subtype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$SubType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any, but at least T.\n\nexport default class $SuperType<T> extends Type<$Supertype<T>> {\n  typeName: string = '$SuperType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Supertype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Supertype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$SuperType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport TupleType from '../types/TupleType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the values in a tuple.\n\nexport default class $TupleMapType<T: [], M: Mapper> extends Type<$TupleMap<T, M>> {\n  typeName: string = '$TupleMapType';\n\n  tuple: Type<T>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const expected = applied.invoke(type);\n      const value = input[i];\n      yield* expected.errors(validation, path.concat(i), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      if (!applied.invoke(type).accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$TupleMap<T, M>> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n    const args = [];\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(applied.invoke(type).unwrap().unwrap());\n    }\n\n    return context.tuple(...args);\n  }\n\n  toString (): string {\n    return `$TupleMap<${this.tuple.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      tuple: this.tuple,\n      mapper: this.mapper\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$TupleMapType.js","/* @flow */\n\nimport TypeInferrer from './TypeInferrer';\nimport primitiveTypes from './primitiveTypes';\nimport invariant from './invariant';\n\nimport Validation from './Validation';\n\nimport makeReactPropTypes from './makeReactPropTypes';\n\nimport makeJSONError from './errorReporting/makeJSONError';\nimport makeTypeError from './errorReporting/makeTypeError';\nimport makeWarningMessage from './errorReporting/makeWarningMessage';\n\nimport makeUnion from './makeUnion';\nimport compareTypes from './compareTypes';\nimport {makePropertyDescriptor} from './classDecorators';\n\nimport {flowIntoTypeParameter} from './types/TypeParameter';\n\nimport annotateValue from './annotateValue';\n\nimport type {PropTypeDict} from './makeReactPropTypes';\nimport type {IdentifierPath, ErrorTuple} from './Validation';\n\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType\n} from './types';\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport {\n  $DiffType,\n  $FlowFixMeType,\n  $KeysType,\n  $ObjMapiType,\n  $ObjMapType,\n  $PropertyType as _$PropertyType,\n  $ShapeType,\n  $SubType,\n  $SuperType,\n  $TupleMapType,\n  ClassType\n} from './flowTypes';\n\nimport {\n  ParentSymbol,\n  NameRegistrySymbol,\n  ModuleRegistrySymbol,\n  CurrentModuleSymbol,\n  TypeConstructorRegistrySymbol,\n  TypeParametersSymbol,\n  InferrerSymbol,\n  TypePredicateRegistrySymbol,\n  TypeSymbol\n} from './symbols';\n\nimport type {\n  TypeConstraint,\n  TypeCreator,\n  TypeRevealer,\n  FunctionBodyCreator,\n  ApplicableType,\n  ValidFunctionBody,\n  ObjectPropertyDict,\n  ValidObjectBody\n} from './types';\n\nimport type {\n  ClassBodyCreator,\n  ValidClassBody\n} from './declarations';\n\nexport type TypeConstructorConfig = {\n  name: string;\n  impl?: Function;\n  typeName: string;\n  errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void>;\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean;\n  inferTypeParameters (input: any): Type<any>[];\n};\n\nexport type TypePredicate = (input: any) => boolean;\n\ntype NameRegistry = {\n  [name: string]: Type<any> | Class<TypeConstructor<any>>;\n};\n\ntype TypePredicateRegistry = {\n  [name: string]: TypePredicate;\n};\n\ntype ModuleRegistry = {\n  [name: string]: ModuleDeclaration;\n};\n\ntype TypeConstructorRegistry = Map<Function, Class<TypeConstructor<any>>>;\n\nexport type MatchClause<P, R> = (...params: P[]) => R;\nexport type PatternMatcher<P, R> = (...params: P[]) => R;\n\nexport type CheckMode\n  = 'assert'\n  | 'warn'\n  ;\n\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nconst warnedInvalidReferences: WeakSet<any> = new WeakSet();\n\nexport default class TypeContext {\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n  mode: CheckMode = 'assert';\n\n  // @flowIssue 252\n  [ParentSymbol]: ? TypeContext;\n\n  // @flowIssue 252\n  [NameRegistrySymbol]: NameRegistry = {};\n\n  // @flowIssue 252\n  [TypePredicateRegistrySymbol]: TypePredicateRegistry = {};\n\n  // @flowIssue 252\n  [TypeConstructorRegistrySymbol]: TypeConstructorRegistry = new Map();\n\n  // @flowIssue 252\n  [InferrerSymbol]: TypeInferrer = new TypeInferrer(this);\n\n  // @flowIssue 252\n  [ModuleRegistrySymbol]: ModuleRegistry = {};\n\n  // @flowIssue 252\n  [CurrentModuleSymbol]: ? ModuleDeclaration;\n\n  get TypeParametersSymbol (): typeof TypeParametersSymbol {\n    return TypeParametersSymbol;\n  }\n\n\n  makeJSONError <T> (validation: Validation<T>): ? Array<Object> {\n    return makeJSONError(validation);\n  }\n\n  makeTypeError <T> (validation: Validation<T>): ? TypeError {\n    return makeTypeError(validation);\n  }\n\n  createContext (): TypeContext {\n    const context = new TypeContext();\n    // @flowIssue 252\n    context[ParentSymbol] = this;\n    return context;\n  }\n\n  typeOf <T> (input: T): Type<T> {\n\n    const annotation = this.getAnnotation(input);\n    if (annotation) {\n      if (typeof input === 'function' && (annotation instanceof ClassDeclaration || annotation instanceof ParameterizedClassDeclaration)) {\n        return this.Class(annotation);\n      }\n      return annotation;\n    }\n    // @flowIssue 252\n    const inferrer = this[InferrerSymbol];\n    (inferrer: TypeInferrer);\n\n    return inferrer.infer(input);\n  }\n\n  compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n    return compareTypes(a, b);\n  }\n\n  get (name: string, ...propertyNames: string[]): ? Type<any> {\n    // @flowIssue 252\n    const item = this[NameRegistrySymbol][name];\n    if (item != null) {\n      let current = typeof item === 'function'\n                  ? new item(this)\n                  : item\n                  ;\n      for (let i = 0; i < propertyNames.length; i++) {\n        const propertyName = propertyNames[i];\n        if (typeof current.getProperty !== 'function') {\n          return;\n        }\n        current = current.getProperty(propertyName);\n        if (!current) {\n          return;\n        }\n        current = current.unwrap();\n      }\n      return current;\n    }\n    // @flowIssue 252\n    const parent = this[ParentSymbol];\n    if (parent) {\n      const fromParent = parent.get(name, ...propertyNames);\n      if (fromParent) {\n        return fromParent;\n      }\n    }\n\n    // if we got this far, see if we have a global type with this name.\n    if (typeof global[name] === 'function') {\n      const target = new GenericType(this);\n      target.name = name;\n      target.impl = global[name];\n      // @flowIssue 252\n      this[NameRegistrySymbol][name] = target;\n      return target;\n    }\n  }\n\n  /**\n   * Get the predicate for a given type name.\n   * e.g. `t.getPredicate('Array')`.\n   */\n  getPredicate (name: string): ? TypePredicate {\n    const item: ? TypePredicate = (this: any)[TypePredicateRegistrySymbol][name];\n    if (item) {\n      return item;\n    }\n    const parent: ? TypeContext = (this: any)[ParentSymbol];\n    if (parent) {\n      return parent.getPredicate(name);\n    }\n  }\n\n  /**\n   * Set the predicate for a given type name.\n   * This can be used to customise the behaviour of things like Array\n   * detection or allowing Thenables in place of the global Promise.\n   */\n  setPredicate (name: string, predicate: TypePredicate) {\n    (this: any)[TypePredicateRegistrySymbol][name] = predicate;\n  }\n\n  /**\n   * Check the given value against the named predicate.\n   * Returns false if no such predicate exists.\n   * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n   */\n  checkPredicate (name: string, input: any): boolean {\n    const predicate = this.getPredicate(name);\n    if (predicate) {\n      return predicate(input);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Returns a decorator for a function or object with the given type.\n   */\n  decorate (type: (() => Type<any>) | Type<any>, shouldAssert?: boolean): * {\n    if (shouldAssert == null) {\n      shouldAssert = this.mode === 'assert';\n    }\n    return (input: Object | Function, propertyName?: string, descriptor?: Object): * => {\n      if (descriptor && typeof propertyName === 'string') {\n        return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n      }\n      else {\n        invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n        return this.annotate(input, type);\n      }\n    };\n  }\n\n  /**\n   * Annotates an object or function with the given type.\n   * If a type is specified as the sole argument, returns a\n   * function which can decorate classes or functions with the given type.\n   */\n  annotate <T> (input: Type<T> | T, type?: Type<T>) {\n    if (type === undefined) {\n      return annotateValue(input);\n    }\n    else {\n      return annotateValue(input, type);\n    }\n  }\n\n  getAnnotation <T> (input: T): ? Type<T> {\n    if ((input !== null && typeof input === 'object') || typeof input === 'function') {\n      // @flowIssue 252\n      return input[TypeSymbol];\n    }\n  }\n\n  hasAnnotation (input: any): boolean {\n    if (input == null) {\n      return false;\n    }\n    else {\n      return input[TypeSymbol] ? true : false;\n    }\n  }\n\n  setAnnotation <T: Object | Function> (input: T, type: Type<T>): T {\n    input[TypeSymbol] = type;\n    return input;\n  }\n\n  type <T> (name: string, type: Type<T> | TypeCreator<Type<T>>): TypeAlias<T> | ParameterizedTypeAlias<T> {\n    if (typeof type === 'function') {\n      const target = new ParameterizedTypeAlias(this);\n      target.name = name;\n      target.typeCreator = type;\n      return target;\n    }\n    else {\n      const target = new TypeAlias(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }\n\n  declare <T: any, D: ModuleDeclaration | TypeDeclaration<T> | VarDeclaration<T> | ClassDeclaration<T>> (name: string | D, type?: Type<T> | TypeCreator<Type<T>>): D | TypeDeclaration<T> {\n\n    if (name instanceof Declaration) {\n      type = name;\n      name = type.name;\n    }\n    else if (name instanceof TypeAlias) {\n      type = name;\n      name = type.name;\n    }\n    if (typeof type === 'function') {\n      type = this.type(name, type);\n    }\n    if (type instanceof ModuleDeclaration) {\n      const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n      moduleRegistry[name] = type;\n      return type;\n    }\n    else {\n      invariant(typeof name === 'string', 'Name must be a string');\n      invariant(type instanceof Type, 'Type must be supplied to declaration');\n      const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n      if (type instanceof Declaration) {\n        nameRegistry[name] = type;\n        return type;\n      }\n      else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n        const target = new TypeDeclaration(this);\n        target.name = name;\n        target.typeAlias = type;\n        nameRegistry[name] = target;\n        return target;\n      }\n      else {\n        const target = this.var(name, type);\n        nameRegistry[name] = target;\n        return target;\n      }\n    }\n  }\n\n  *declarations (): Generator<[string, Type<any> | TypeConstructor<any>], void, void> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n    for (const key in nameRegistry) { // eslint-disable-line guard-for-in\n      yield [key, nameRegistry[key]];\n    }\n  }\n\n  *modules (): Generator<ModuleDeclaration, void, void> {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    for (const key in moduleRegistry) { // eslint-disable-line guard-for-in\n      yield moduleRegistry[key];\n    }\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    if (moduleRegistry[moduleName]) {\n      return moduleRegistry[moduleName];\n    }\n    const [head] = moduleName.split('/');\n    const module = moduleRegistry[head];\n    if (module) {\n      return module.import(moduleName);\n    }\n    const parent = (this: $FlowIssue<252>)[ParentSymbol];\n    if (parent) {\n      return parent.import(moduleName);\n    }\n  }\n\n  declareTypeConstructor ({name, impl, typeName, errors, accepts, inferTypeParameters}: TypeConstructorConfig): TypeConstructor<any> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n    if (nameRegistry[name]) {\n      this.emitWarningMessage(`Redeclaring type: ${name}, this may be unintended.`);\n    }\n\n    const target = new TypeConstructor(this);\n    target.name = name;\n    target.typeName = typeName;\n    target.impl = impl;\n    target.errors = errors;\n    target.accepts = accepts;\n    target.inferTypeParameters = inferTypeParameters;\n\n    nameRegistry[name] = target;\n\n    if (typeof impl === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      if (handlerRegistry.has(impl)) {\n        this.emitWarningMessage(`A type handler already exists for the given implementation of ${name}.`);\n      }\n      handlerRegistry.set(impl, target);\n    }\n    return target;\n  }\n\n  getTypeConstructor (impl: Function): ? TypeConstructor<any> {\n    // @flowIssue 252\n    const handlerRegistry = this[TypeConstructorRegistrySymbol];\n    (handlerRegistry: TypeConstructorRegistry);\n\n    return handlerRegistry.get(impl);\n  }\n\n  literal <T: void | null | boolean | number | string | Symbol> (input: T): Type<T> {\n    if (input === undefined) {\n      return this.void();\n    }\n    else if (input === null) {\n      return this.null();\n    }\n    else if (typeof input === 'boolean') {\n      return this.boolean(input);\n    }\n    else if (typeof input === 'number') {\n      return this.number(input);\n    }\n    else if (typeof input === 'string') {\n      return this.string(input);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return this.symbol(input);\n    }\n    else {\n      return this.typeOf(input);\n    }\n  }\n\n  null (): NullLiteralType {\n    return primitiveTypes.null;\n  }\n\n  nullable <T> (type: Type<T>): NullableType<? T> {\n    const target = new NullableType(this);\n    target.type = type;\n    return target;\n  }\n\n  existential (): ExistentialType {\n    return primitiveTypes.existential;\n  }\n\n\n  empty (): EmptyType {\n    return primitiveTypes.empty;\n  }\n\n  any (): AnyType {\n    return primitiveTypes.any;\n  }\n\n  mixed (): MixedType {\n    return primitiveTypes.mixed;\n  }\n\n  void (): VoidType {\n    return primitiveTypes.void;\n  }\n\n  this <T> (input?: T): ThisType<T> {\n    const target = new ThisType(this);\n    if (input !== undefined) {\n      target.recorded = input;\n    }\n    return target;\n  }\n\n  number <T: number> (input?: T): NumberType | NumericLiteralType<T> {\n    if (input !== undefined) {\n      const target = new NumericLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.number;\n    }\n  }\n\n  boolean <T: boolean> (input?: T): BooleanType | BooleanLiteralType<T> {\n    if (input !== undefined) {\n      const target = new BooleanLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.boolean;\n    }\n  }\n\n  string <T: string> (input?: T): StringType | StringLiteralType<T> {\n    if (input !== undefined) {\n      const target = new StringLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.string;\n    }\n  }\n\n  symbol <T: Symbol> (input?: T): SymbolType | SymbolLiteralType<T> {\n    if (input !== undefined) {\n      const target = new SymbolLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.symbol;\n    }\n  }\n\n  typeParameter <T> (id: string, bound?: Type<T>, defaultType?: Type<T>): TypeParameter<T> {\n    const target = new TypeParameter(this);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    return target;\n  }\n\n  flowInto <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n    return flowIntoTypeParameter(typeParameter);\n  }\n\n  /**\n   * Bind the type parameters for the parent class of the given instance.\n   */\n  bindTypeParameters <T: {}> (subject: T, ...typeInstances: Type<any>[]): T {\n    const instancePrototype = Object.getPrototypeOf(subject);\n    // @flowIssue\n    const parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n    // @flowIssue\n    const parentClass = parentPrototype && parentPrototype.constructor;\n\n    if (!parentClass) {\n      this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n      return subject;\n    }\n    // @flowIssue 252\n    const typeParametersPointer = parentClass[TypeParametersSymbol];\n\n    if (typeParametersPointer) {\n      const typeParameters = subject[typeParametersPointer];\n      const keys = Object.keys(typeParameters);\n      const length = Math.min(keys.length, typeInstances.length);\n      for (let i = 0; i < length; i++) {\n        const typeParam = typeParameters[keys[i]];\n        typeParam.bound = typeInstances[i];\n      }\n    }\n    return subject;\n  }\n\n  module (name: string, body: (context: TypeContext) => any): ModuleDeclaration {\n    const target = new ModuleDeclaration(this);\n    target.name = name;\n    const innerContext = this.createContext();\n    // @flowIssue 252\n    innerContext[ParentSymbol] = this;\n    // @flowIssue 252\n    innerContext[CurrentModuleSymbol] = target;\n\n    target.innerContext = innerContext;\n    body(innerContext);\n    return target;\n  }\n\n  moduleExports <T> (type: Type<T>): ModuleExportsDeclaration<T> {\n    const currentModule: ModuleDeclaration = (this: $FlowIssue<252>)[CurrentModuleSymbol];\n    if (!currentModule) {\n      throw new Error('Cannot declare module.exports outside of a module.');\n    }\n    const target = new ModuleExportsDeclaration(this);\n    target.type = type;\n    currentModule.moduleExports = target;\n    return target;\n  }\n\n  var <T> (name: string, type: Type<T>): VarDeclaration<T> {\n    const target = new VarDeclaration(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  class <X, O: {}> (name: string, head?: ClassBodyCreator<X, O> | ValidClassBody<X, O>, ...tail: Array<ValidClassBody<X, O>>): ClassDeclaration<O> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedClassDeclaration(this);\n      target.name = name;\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new ClassDeclaration(this);\n    target.name = name;\n    if (head != null) {\n      tail.unshift(head);\n    }\n    const {length} = tail;\n    const properties = [];\n    let body;\n\n    for (let i = 0; i < length; i++) {\n      const item = tail[i];\n      if (item instanceof ObjectTypeProperty || item instanceof ObjectTypeIndexer) {\n        properties.push(item);\n      }\n      else if (item instanceof ObjectType) {\n        invariant(!body, 'Class body must only be declared once.');\n        body = item;\n      }\n      else if (item instanceof ExtendsDeclaration) {\n        invariant(!target.superClass, 'Classes can only have one super class.');\n        target.superClass = item;\n      }\n      else if (item != null && typeof item === 'object' && !(item instanceof Type)) {\n        for (const propertyName in item) { // eslint-disable-line\n          properties.push(this.property(propertyName, (item: any)[propertyName]));\n        }\n      }\n      else {\n        throw new Error('ClassDeclaration cannot contain the given type directly.');\n      }\n    }\n    if (!body) {\n      body = new ObjectType(this);\n    }\n    if (properties.length) {\n      body.properties.push(...properties);\n    }\n    target.body = body;\n    return target;\n  }\n\n  extends <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): ExtendsDeclaration<T> {\n    const target = new ExtendsDeclaration(this);\n    target.type = this.ref(subject, ...typeInstances);\n    return target;\n  }\n\n  fn <X, P, R> (head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    return this.function(head, ...tail);\n  }\n\n  function <X, P, R> (head: ? FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedFunctionType(this);\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new FunctionType(this);\n    if (head != null) {\n      tail.unshift(head);\n      const {length} = tail;\n      for (let i = 0; i < length; i++) {\n        const item = tail[i];\n        if (item instanceof FunctionTypeParam) {\n          target.params.push(item);\n        }\n        else if (item instanceof FunctionTypeRestParam) {\n          target.rest = item;\n        }\n        else if (item instanceof FunctionTypeReturn) {\n          target.returnType = item;\n        }\n        else {\n          throw new Error('FunctionType cannot contain the given type directly.');\n        }\n      }\n    }\n    if (!target.returnType) {\n      target.returnType = this.any();\n    }\n    return target;\n  }\n\n  param <T> (name: string, type: Type<T>, optional: boolean = false): FunctionTypeParam<T> {\n    const target = new FunctionTypeParam(this);\n    target.name = name;\n    target.type = type;\n    target.optional = optional;\n    return target;\n  }\n\n  rest <T> (name: string, type: Type<T>): FunctionTypeRestParam<T> {\n    const target = new FunctionTypeRestParam(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  return <T> (type: Type<T>): FunctionTypeReturn<T> {\n    const target =  new FunctionTypeReturn(this);\n    target.type = type;\n    return target;\n  }\n\n  generator <Y, R, N> (yieldType: Type<Y>, returnType?: Type<R>, nextType?: Type<N>): GeneratorType<Y, R, N> {\n    const target = new GeneratorType(this);\n    target.yieldType = yieldType;\n    target.returnType = returnType || this.any();\n    target.nextType = nextType || this.any();\n    return target;\n  }\n\n  object <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const target = new ObjectType(this);\n    if (head != null && typeof head === 'object' && !(head instanceof Type)) {\n      for (const propertyName in head) { // eslint-disable-line\n        target.properties.push(this.property(propertyName, head[propertyName]));\n      }\n    }\n    else {\n      let body;\n      if (head) {\n        body = [head, ...tail];\n      }\n      else {\n        body = tail;\n      }\n      const {length} = body;\n      for (let i = 0; i < length; i++) {\n        const item = body[i];\n        if (item instanceof ObjectTypeProperty) {\n          target.properties.push(item);\n        }\n        else if (item instanceof ObjectTypeIndexer) {\n          target.indexers.push(item);\n        }\n        else if (item instanceof ObjectTypeCallProperty) {\n          target.callProperties.push(item);\n        }\n        else {\n          throw new Error('ObjectType cannot contain the given type directly.');\n        }\n      }\n    }\n    return target;\n  }\n\n  exactObject <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const object = this.object(head, ...tail);\n    object.exact = true;\n    return object;\n  }\n\n  callProperty <T> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const target = new ObjectTypeCallProperty(this);\n    target.value = value;\n    return target;\n  }\n\n  property <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const target = new ObjectTypeProperty(this);\n    target.key = key;\n    if (value instanceof Type) {\n      target.value = value;\n    }\n    else {\n      target.value = this.object(value);\n    }\n    target.optional = optional;\n    return target;\n  }\n\n  indexer <K, V> (id: string, key: Type<K>, value: Type<V>): ObjectTypeIndexer<K, V> {\n    const target = new ObjectTypeIndexer(this);\n    target.id = id;\n    target.key = key;\n    target.value = value;\n    return target;\n  }\n\n  method <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const target = new ObjectTypeProperty(this);\n    target.key = name;\n    target.value = this.function(head, ...tail);\n    return target;\n  }\n\n  staticCallProperty <T: Function> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const prop = this.callProperty(value);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticProperty <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const prop = this.property(key, value, optional);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticMethod <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const prop = this.method(name, head, ...tail);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  tuple <T> (...types: Type<T>[]): TupleType<any> {\n    const target = new TupleType(this);\n    target.types = types;\n    return target;\n  }\n\n  array <T> (elementType?: Type<T>): ArrayType<T> {\n    const target = new ArrayType(this);\n    target.elementType = elementType || this.any();\n    return target;\n  }\n\n  union <T> (...types: Type<T>[]): Type<T> {\n    return makeUnion(this, types);\n  }\n\n  intersect <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    const target = new IntersectionType(this);\n    target.types = types;\n    return target;\n  }\n\n  intersection <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    return this.intersect(...types);\n  }\n\n  box <T> (reveal: TypeRevealer<T>): TypeBox<T> {\n    const box = new TypeBox(this);\n    box.reveal = reveal;\n    return box;\n  }\n\n  tdz <T> (reveal: TypeRevealer<T>, name?: string): TypeTDZ<T> {\n    const tdz = new TypeTDZ(this);\n    tdz.reveal = reveal;\n    tdz.name = name;\n    return tdz;\n  }\n\n  ref <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): Type<T | any> {\n    let target;\n    if (typeof subject === 'string') {\n      // try and eagerly resolve the reference\n      target = this.get(subject);\n      if (!target) {\n        // defer dereferencing for now\n        target = new TypeReference(this);\n        target.name = subject;\n      }\n    }\n    else if (typeof subject === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      // see if we have a dedicated TypeConstructor for this.\n      target = handlerRegistry.get(subject);\n\n      if (!target) {\n        // just use a generic type handler.\n        target = new GenericType(this);\n        target.impl = subject;\n        target.name = subject.name;\n      }\n\n    }\n    else if (subject instanceof Type) {\n      target = subject;\n    }\n    else {\n      if (subject == null || typeof subject !== 'object') {\n        this.emitWarningMessage(`Could not reference the given type, try t.typeOf(value) instead. (got ${String(subject)})`);\n      }\n      else if (!warnedInvalidReferences.has(subject)) {\n        this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n        warnedInvalidReferences.add(subject);\n      }\n      return this.any();\n    }\n\n    if (typeInstances.length) {\n      invariant(typeof target.apply === 'function', `Cannot apply non-applicable type: ${target.typeName}.`);\n      return target.apply(...typeInstances);\n    }\n    else {\n      return target;\n    }\n  }\n\n  validate <T> (type: Type<T>, input: any, prefix: string = '', path?: string[]): Validation<T> {\n    const validation = new Validation(this, input);\n    if (path) {\n      validation.path.push(...path);\n    }\n    else if (typeof type.name === 'string') {\n      validation.path.push(type.name);\n    }\n    validation.prefix = prefix;\n    validation.errors = Array.from(type.errors(validation, [], input));\n    return validation;\n  }\n\n  check <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    if (this.mode === 'assert') {\n      return this.assert(type, input, prefix, path);\n    }\n    else {\n      return this.warn(type, input, prefix, path);\n    }\n  }\n\n  assert <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const error = this.makeTypeError(validation);\n    if (error) {\n      throw error;\n    }\n    return input;\n  }\n\n  warn <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const message = makeWarningMessage(validation);\n    if (typeof message === 'string') {\n      this.emitWarningMessage(message);\n    }\n    return input;\n  }\n\n  /**\n   * Emits a warning message, using `console.warn()` by default.\n   */\n  emitWarningMessage (message: string): void {\n    console.warn('flow-runtime:', message);\n  }\n\n  propTypes <T: {}> (type: Type<T>): PropTypeDict<T> {\n    return makeReactPropTypes((type.unwrap(): $FlowIgnore));\n  }\n\n  match <P, R> (...args: Array<P | MatchClause<P, R>>): R {\n    const clauses: any = args.pop();\n    if (!Array.isArray(clauses)) {\n      throw new Error('Invalid pattern, last argument must be an array.');\n    }\n    (clauses: MatchClause<P, R>[]);\n    const pattern = this.pattern(...clauses);\n    return pattern(...args);\n  }\n\n  pattern <P, R> (...clauses: MatchClause<P, R>[]): PatternMatcher<P, R> {\n    const {length} = clauses;\n    const tests: Array<true | FunctionType<P, R> | ParameterizedFunctionType<any, P, R>> = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const clause = clauses[i];\n      const annotation = this.getAnnotation(clause);\n      if (!annotation) {\n        if (i !== length - 1) {\n          throw new Error(`Invalid Pattern - found unannotated function in position ${i}, default clauses must be last.`);\n        }\n        tests[i] = true;\n      }\n      else {\n        invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n        tests[i] = annotation;\n      }\n    }\n    return (...args: P[]): R => {\n      for (let i = 0; i < tests.length; i++) {\n        const test = tests[i];\n        const clause = clauses[i];\n        if (test === true) {\n          return clause(...args);\n        }\n        else if (test.acceptsParams(...args)) {\n          return clause(...args);\n        }\n      }\n      const error = new TypeError('Value did not match any of the candidates.');\n      error.name = 'RuntimeTypeError';\n      throw error;\n    };\n  }\n\n  wrapIterator <T> (type: Type<T>): (input: Iterable<T>) => Generator<T, void, void> {\n    const t = this;\n    return function* wrappedIterator (input: Iterable<T>): Generator<T, void, void> {\n      for (const item of input) {\n        yield t.check(type, item);\n      }\n    };\n  }\n\n  refinement <T> (type: Type<T>, ...constraints: TypeConstraint[]): RefinementType<T> {\n    const target = new RefinementType(this);\n    target.type = type;\n    target.addConstraint(...constraints);\n    return target;\n  }\n\n\n  $diff <A: {}, B: {}> (aType: Type<A>, bType: Type<B>): $DiffType<A, B> {\n    const target = new $DiffType(this);\n    target.aType = aType;\n    target.bType = bType;\n    return target;\n  }\n\n  $flowFixMe (): $FlowFixMeType {\n    return new $FlowFixMeType(this);\n  }\n\n  $keys <T: {}> (type: Type<T>): $KeysType<T> {\n    const target = new $KeysType(this);\n    target.type = type;\n    return target;\n  }\n\n  $objMap <O: {}, K: $Keys<O>, M: (k: K) => any> (object: Type<O>, mapper: Type<M>): $ObjMapType<O, M> {\n    const target = new $ObjMapType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $objMapi <O: {}, K: $Keys<O>, M: (k: K, v: any) => any> (object: Type<O>, mapper: Type<M>): $ObjMapiType<O, M> {\n    const target = new $ObjMapiType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $propertyType <O: {}, P: string | number | Symbol> (object: Type<O>, property: P | Type<P>): _$PropertyType<O, P> {\n    const target = new _$PropertyType(this);\n    target.object = object;\n    if (property instanceof Type) {\n      const unwrapped = property.unwrap();\n      target.property = (unwrapped: any).value;\n    }\n    else {\n      target.property = property;\n    }\n    return target;\n  }\n\n  $shape <T: {}> (type: Type<T>): $ShapeType<T> {\n    const target = new $ShapeType(this);\n    target.type = type;\n    return target;\n  }\n\n  $subtype <T: {}> (type: Type<T>): $SubType<T> {\n    const target = new $SubType(this);\n    target.type = type;\n    return target;\n  }\n\n  $supertype <T: {}> (type: Type<T>): $SuperType<T> {\n    const target = new $SuperType(this);\n    target.type = type;\n    return target;\n  }\n\n  $tupleMap <T: [], M: (v: *) => *> (tuple: Type<T>, mapper: Type<M>): $TupleMapType<T, M> {\n    const target = new $TupleMapType(this);\n    target.tuple = tuple;\n    target.mapper = mapper;\n    return target;\n  }\n\n  Class <T: {}> (instanceType: Type<T>): ClassType<T> {\n    const target = new ClassType(this);\n    target.instanceType = instanceType;\n    return target;\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/TypeContext.js","/* @flow */\n\nimport registerPrimitiveTypes from './registerPrimitiveTypes';\nimport registerBuiltinTypeConstructors from './registerBuiltins';\nimport registerTypePredicates from './registerTypePredicates';\n\nimport TypeContext from './TypeContext';\n\nlet globalContext;\nif (typeof global !== 'undefined' && typeof global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== 'undefined') {\n  globalContext = global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__;\n}\nelse {\n  globalContext = new TypeContext();\n  registerPrimitiveTypes(globalContext);\n  registerBuiltinTypeConstructors(globalContext);\n  registerTypePredicates(globalContext);\n  if (typeof global !== 'undefined') {\n    global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ = globalContext;\n  }\n}\n\n\nexport default globalContext;\n\n\n// WEBPACK FOOTER //\n// ../src/globalContext.js","/* @flow */\n\nimport primitiveTypes from './primitiveTypes';\n\nimport type TypeContext from './TypeContext';\n\nimport {\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\nexport default function registerPrimitiveTypes (t: TypeContext): TypeContext {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/registerPrimitiveTypes.js","/* @flow */\nimport getErrorMessage from './getErrorMessage';\n\nimport invariant from './invariant';\n\nimport {Type} from './types';\n\nimport type TypeContext from './TypeContext';\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport default function registerBuiltinTypeConstructors (t: TypeContext): TypeContext {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n      if (!(input instanceof Date)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Date'), this];\n      }\n      else if (isNaN(input.getTime())) {\n        yield [path, getErrorMessage('ERR_INVALID_DATE'), this];\n      }\n    },\n    accepts (input): boolean {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    inferTypeParameters (input: Date): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, futureType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(futureType, 'Must specify type parameter for Promise.');\n      const {context} = this;\n      if (!context.checkPredicate('Promise', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_PROMISE', futureType), this];\n      }\n    },\n    accepts (input): boolean {\n      const {context} = this;\n      return context.checkPredicate('Promise', input);\n    },\n    inferTypeParameters (input: any): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, keyType?: Type<any>, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(keyType, 'Must specify two type parameters for Map.');\n      invariant(valueType, 'Must specify two type parameters for Map.');\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'), this];\n        return;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key)) {\n          yield [path, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType), this];\n        }\n\n        yield* valueType.errors(validation, path.concat(key), value);\n      }\n    },\n    accepts (input, keyType: Type<any>, valueType: Type<any>): boolean {\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key) || !valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    inferTypeParameters (input: Map<*, *>): Type<any>[] {\n      const keyTypes = [];\n      const valueTypes = [];\n      loop: for (const [key, value] of input) {\n        findKey: {\n          for (let i = 0; i < keyTypes.length; i++) {\n            const type = keyTypes[i];\n            if (type.accepts(key)) {\n              break findKey;\n            }\n          }\n          keyTypes.push(t.typeOf(key));\n        }\n\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      const typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(valueType, 'Must specify type parameter for Set.');\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'), this];\n        return;\n      }\n      for (const value of input) {\n        yield* valueType.errors(validation, path, value);\n      }\n    },\n    accepts (input, valueType) {\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      for (const value of input) {\n        if (!valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    inferTypeParameters (input: Set<*>): Type<any>[] {\n      const valueTypes = [];\n      loop: for (const value of input) {\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      }\n      else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      }\n      else {\n        return [t.union(...valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/registerBuiltins.js","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nexport default function registerTypePredicates (context: TypeContext) {\n  context.setPredicate('Array', (input: any) => Array.isArray(input));\n  context.setPredicate('Map', (input: any) => input instanceof Map);\n  context.setPredicate('Set', (input: any) => input instanceof Set);\n  context.setPredicate('Promise', (input: any) => {\n    if (input instanceof Promise) {\n      return true;\n    } else {\n      return input !== null\n        && (typeof input === 'object' || typeof input === 'function')\n        && typeof input.then === 'function'\n        ;\n    }\n  });\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/registerTypePredicates.js","/* @flow */\n\nexport default function reduce(\n    reducer : (r : any, t : any, i : number, array : any[]) => any,\n    _start? : any,\n) : (array : any[], start? : any) => any\n{\n    return (array : any[], start? : any = _start) : any =>\n    {\n        let ret : any = start;\n        \n        for (let i = 0; i < array.length; i++)\n            ret = reducer(ret, array[i], i, array);\n        \n        return ret;\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// array/reduce.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 2\n// module chunks = 0","/* @flow */\n\nimport reduce from \"./reduce\";\n\nexport default function filter(\n    filter : (t : any, i : number, array : any[]) => boolean,\n) : (array : any[]) => any[]\n{\n    return reduce(\n        (r : any[], t : any, i : number, array : any[]) : any[] =>\n            filter(t, i, array) ? r.concat([\n                t,\n            ]) : r,\n        [],\n    );\n}\n\n\n\n// WEBPACK FOOTER //\n// array/filter.js","/* @flow */\n\nexport default function processors(\n    preProcessor : ((args : any[]) => any[]) | null = null,\n    postProcessor : ((value : any) => any) | null = null,\n) : (fn : (...args : any[]) => any) => any\n{\n    if (preProcessor === null)\n        preProcessor = args => args;\n    \n    if (postProcessor === null)\n        postProcessor = value => value;\n    \n    return (fn : (...args : any[]) => any) : any =>\n        (...args) =>\n            postProcessor(fn(...preProcessor(args)));\n}\n\n\n\n// WEBPACK FOOTER //\n// function/processors.js","/* @flow */\n\nimport reduce from \"./reduce\";\n\nexport default function map(\n    mapper : (t : any, i : number, array : any[]) => any,\n) : (array : any[]) => any[]\n{\n    return reduce(\n        (r : any[], t : any, i : number, array : any[]) : any[] =>\n            r.concat(mapper(t, i, array)),\n        [],\n    );\n}\n\n\n\n// WEBPACK FOOTER //\n// array/map.js","/* @flow */\n\nexport default function shift(\n    shift? : number = 1,\n) : (array : any[]) => any[]\n{\n    return (array : any[]) : any[] =>\n    {\n        const ret = [];\n        \n        for (let i = shift; i < array.length; i++)\n            ret.push(array[i]);\n        \n        return ret;\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// array/shift.js","/* @flow */\n\nexport default function concat(\n    concat : any,\n) : (array : any[]) => any[]\n{\n    return (array : any[]) : any[] =>\n        array.concat(concat);\n};\n\n\n\n// WEBPACK FOOTER //\n// array/concat.js","/* @flow */\n\nimport filter from \"./filter\";\nimport processors from \"../function/processors\";\n\nexport default function find(\n    finder : (t : any, i : number, array : any[]) => boolean,\n) : (array : any[]) => any\n{\n    return (processors(\n        null,\n        (value : any[]) : any =>\n            value.length > 0 ? value[0] : undefined,\n    )(filter(finder)) : (array : any[]) => any);\n}\n\n\n\n// WEBPACK FOOTER //\n// array/find.js","/* @flow */\n\nimport reduce from \"./reduce\";\n\nexport default function flatten(array : any[]) : any[]\n{\n    return reduce(\n        (r : any, t : any, i : number, array : any[]) =>\n            r.concat(t),\n        [],\n    )(array);\n}\n\n\n\n// WEBPACK FOOTER //\n// array/flatten.js","/* @flow */\n\nimport map from \"./map\";\n\nexport default function mapKey(\n    key : string,\n) : (array : Object[]) => any[]\n{\n    return map(\n        (t : Object, i : number, array : Object[]) : any =>\n            t[key],\n    );\n}\n\n\n\n// WEBPACK FOOTER //\n// array/mapKey.js","/* @flow */\n\nexport default function reverse(\n    array : any[],\n) : any[]\n{\n    const ret = [];\n    \n    for (let i = array.length - 1; i >= 0; i--)\n        ret.push(array[i]);\n    \n    return ret;\n}\n\n\n\n// WEBPACK FOOTER //\n// array/reverse.js","/* @flow */\n\nexport default function invert(\n    boolean : boolean | (...args : any[]) => boolean,\n) : boolean | (...args : any[]) => boolean\n{\n    if (typeof boolean === \"function\")\n        return (...args : any[]) : boolean =>\n            ! boolean(...args);\n    else\n        return ! boolean;\n}\n\n\n\n// WEBPACK FOOTER //\n// boolean/invert.js","/* @flow */\n\nexport default function extend(\n    source : Object,\n) : (target : Object) => Object\n{\n    return (target : Object) : Object =>\n        Object.assign(target, source);\n}\n\n\n\n// WEBPACK FOOTER //\n// object/extend.js","/* @flow */\n\nimport chain from \"../utils/chain\";\nimport shift from \"../array/shift\";\n\nexport default function withProperty(\n    keys : string | (number | string)[],\n    value : any,\n) : (obj : Object) => Object\n{\n    return (obj : Object) : Object =>\n    {\n        keys = chain([]).concat(keys).reduce(\n            (r, t) =>\n                chain(r).concat(typeof t === \"string\" ? t.split(\".\") : t).value(),\n            [],\n        ).value();\n        \n        if (keys.length > 1)\n            return withProperty(keys[0], withProperty(shift()(keys), value)(obj[keys[0]]))(obj);\n        \n        return Object.assign(obj, {\n            [keys[0]]: value,\n        });\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// object/withProperty.js","/* @flow */\n\n/* array */\nimport concat from \"../array/concat\";\nimport filter from \"../array/filter\";\nimport find from \"../array/find\";\nimport flatten from \"../array/flatten\";\nimport map from \"../array/map\";\nimport mapKey from \"../array/mapKey\";\nimport reduce from \"../array/reduce\";\nimport reverse from \"../array/reverse\";\nimport shift from \"../array/shift\";\n\n/* boolean */\nimport invert from \"../boolean/invert\";\n\n/* function */\nimport processors from \"../function/processors\";\n\n/* math */\nimport sum from \"../math/sum\";\n\n/* object */\nimport extend from \"../object/extend\";\nimport withProperty from \"../object/withProperty\";\n\nconst CHAINABLE = {\n    /* array */\n    concat,\n    filter,\n    find,\n    flatten: () => flatten,\n    map,\n    mapKey,\n    reduce,\n    reverse: () => reverse,\n    shift,\n    \n    /* boolean */\n    invert: () => invert,\n    \n    /* function */\n    processors,\n    \n    /* math */\n    add: (...numbers : number[]) =>\n        sum.bind(null, ...numbers),\n    \n    /* object */\n    extend,\n    withProperty,\n};\n\nclass Chain\n{\n    constructor(initialValue : any)\n    {\n        this.actions = [];\n        this.initialValue = initialValue;\n    }\n    \n    tap(action : (value : any) => any) : Chain\n    {\n        this.actions.push(action);\n        \n        return this;\n    }\n    \n    value() : any\n    {\n        let value = this.initialValue;\n        \n        for (const action of this.actions)\n                value = action(value);\n        \n        return value;\n    }\n}\n\nfor (const chainable in CHAINABLE)\n    Chain.prototype[chainable] = function (...args : any[]) : Chain\n    {\n        return this.tap(CHAINABLE[chainable](...args));\n    };\n\nexport default function chain(initialValue : any) : Chain\n{\n    return new Chain(initialValue);\n}\n\n\n\n// WEBPACK FOOTER //\n// utils/chain.js","/* @flow */\n\nexport const VERSION = \"1.0.0-rc.14\";\n\n/* array */\nexport concat from \"./array/concat\";\nexport filter from \"./array/filter\";\nexport find from \"./array/find\";\nexport flatten from \"./array/flatten\";\nexport map from \"./array/map\";\nexport mapKey from \"./array/mapKey\";\nexport reduce from \"./array/reduce\";\nexport reverse from \"./array/reverse\";\nexport shift from \"./array/shift\";\n\n/* boolean */\nexport invert from \"./boolean/invert\";\n\n/* function */\nexport processors from \"./function/processors\";\n\n/* object */\nexport extend from \"./object/extend\";\nexport withProperty from \"./object/withProperty\";\n\n/* utils */\nexport chain from \"./utils/chain\";\n\n\n\n// WEBPACK FOOTER //\n// core.js","// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/regenerator-runtime/runtime-module.js\n// module id = 17\n// module chunks = 0","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof global.process === \"object\" && global.process.domain) {\n      invoke = global.process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/regenerator-runtime/runtime.js\n// module id = 18\n// module chunks = 0","/* @flow */\n\nimport reduce from \"../array/reduce\";\n\nexport default function sum(...numbers : number[]) : number\n{\n    return reduce((r, t) => r + t, 0)(numbers);\n}\n\n\n\n// WEBPACK FOOTER //\n// math/sum.js"]}